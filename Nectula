game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "ban_notification";
	Text = "This script is converted by ban_thid";
	Icon = "rbxthumb://type=Asset&id=71967665601624&w=150&h=150"})
Duration = 15;

local Object = game:GetObjects("rbxassetid://3224070083")[1]  
Object.Parent = game.Workspace  
script = Object.a

--[[
	Basically now, to convert a script you need to have a bit of basic lua knowledge.
	If you find "game.Players.LocalPlayer" or anything else with LocalPlayer replace it with, "CMouse:GetPlayer()"
	If you find "game.Players.LocalPlayer:GetMouse()" or anything else with :GetMouse() just replace it with, "CMouse"
	If you find "game:GetService("RunService").RenderStepped" or anything else with RenderStepped then just replace RenderStepped with, "Stepped"
	If your stuck watch this. https://streamable.com/kj3hm
	--]]
local S = setmetatable({},{__index = function(self,i) return game:GetService(i) end}) -- Metatable for services indexing
local Ser = {
	Players = S.Players;
	Debris = S.Debris;
	RS = S.RunService;
	TS = S.TweenService;
	JS = S.JointsService;
	UINS = S.UserInputService;
	RunService = S.RunService;
}
local Player = game.Players.LocalPlayer
local Character = Player.Character
local RS = Ser.RunService.Heartbeat
local Mouse = Player:GetMouse()
local Humanoid = Character:WaitForChild("Humanoid")
local Body = {
	Head = Character:WaitForChild("Head");
	Torso = Character:WaitForChild("Torso");
	RootPart = Character:WaitForChild("HumanoidRootPart");
	RA = Character:WaitForChild("Right Arm");
	LA = Character:WaitForChild("Left Arm");
	RL = Character:WaitForChild("Right Leg");
	LL = Character:WaitForChild("Left Leg");
}
local Joints = {
	Neck =  Body.Torso:WaitForChild("Neck");
	Root = Body.RootPart:WaitForChild("RootJoint");
	RS = Body.Torso:WaitForChild("Right Shoulder");
	LS = Body.Torso:WaitForChild("Left Shoulder");
	RH = Body.Torso:WaitForChild("Right Hip");
	LH = Body.Torso:WaitForChild("Left Hip");
}
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}
local ATTACK = false

local IT = Instance.new
local CF = CFrame.new
local VT = Vector3.new
local ANGLES = CFrame.Angles
local RAD = math.rad
local DEGREE = math.deg
local ABS = math.abs
local COS = math.cos
local SIN = math.sin
local FLOOR = math.floor
local CEIL = math.ceil
local MHUGE = math.huge
local RANDOM = math.random
local ACOS = math.acos
local ASIN = math.asin
local HUGE = VT(MHUGE,MHUGE,MHUGE)
local C3 = Color3.new
local BRICKC = BrickColor.new
local ANIM = "Idle"
local SINE = 0

local MainColor = C3(1,0,1/100)

local Effects = IT("Folder",Character)
Effects.Name = "Effects"

local ToDelet = {}
local Invis = {}

--// HEARTBEAT \\--
local ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

local frame = 1/60
local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
ArtificialHB:Fire()

RS:Connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1,FLOOR(tf / frame) do
				ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * FLOOR(tf / frame)
		end
	end
end)

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:Wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:Wait()
		end
	end
	
	return true
end

--// END HEARTBEAT \\--

function New(ClassName, Parent, Properties)
	local NewInstance = IT(ClassName)
		
	if Properties then
		for Index,Prop in pairs(Properties) do
			pcall(function()
				NewInstance[Index] = Prop
			end)
		end
	end
		
	NewInstance.Parent = Parent
	return NewInstance
end

function NoOutlines(Part)
	if not Part:IsA("BasePart") then
		return error("BasePart expected, got ".. Part.ClassName)
	end
	Part.TopSurface, Part.BottomSurface, Part.LeftSurface, Part.RightSurface, Part.FrontSurface, Part.BackSurface = 10, 10, 10, 10, 10, 10	
end

function Sound(Id, Parent, Volume, Pitch, DoesLoop)
	local NewSound = New("Sound", Parent, {SoundId = "rbxassetid://".. tostring(Id), Volume = Volume, Pitch = Pitch, Looped = DoesLoop})
	NewSound:Play()
		
	if DoesLoop == false then
		NewSound.Ended:Connect(function()
			Ser.Debris:AddItem(NewSound,1)
		end)
	end
	
	return NewSound
end

function Part(Material, Color, Size, Parent, Reflectance, Transparency, Name, Anchor)
	local NewPart = New("Part", Parent, {Size = Size,Color = Color, Reflectance = Reflectance, Material = Material, Transparency = Transparency, Name = Name, Anchored = Anchor})
	NoOutlines(NewPart)
	return NewPart
end

function Mesh(Mesh, Part, MeshType, MeshId, MeshTexture, Scale, Offset)
	local NewMesh = New(Mesh, Part, {MeshType = MeshType, Scale = Scale, Offset = Offset})
	
	if MeshId and MeshId ~= "nil" and MeshId ~= "" and MeshId ~= " " then
		NewMesh.MeshId = "rbxassetid://".. tostring(MeshId)
	end
	if MeshTexture and MeshTexture ~= "nil" and MeshTexture ~= "" and MeshTexture ~= " " then
		NewMesh.TextureId = "rbxassetid://".. tostring(MeshTexture)
	end
	
	return NewMesh
end

function Raycast(Pos, Dir, Max, Ignore)
	return workspace:FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function CreateWeld(Part1, Part2) 
	local Weldd = New("Motor", Part1, {Part1 = Part1, Part2 = Part2})
	return Weldd
end

function CustomWeld(Part0, Part1, C0, C1)
	local Weldd = New("Motor", Part0, {Part0 = Part0,Part1 = Part1,C0 = C0 or CF(),C1 = C1 or CF()})
	return Weldd
end

function WeldBetween(Part0, Part1)
	local Weldd = New("Motor", Part0, {Part0 = Part0, Part1 = Part1, C0 = CF(), C1 = Part0.CFrame:inverse() * Part1.CFrame})
	return Weldd
end

function QuaternionFromCFrame(cf)
    local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
    local trace = m00 + m11 + m22
    if trace > 0 then
        local s = math.sqrt(1 + trace)
        local recip = 0.5 / s
        return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
    else
        local i = 0
        if m11 > m00 then
            i = 1
        end
        if m22 > (i == 0 and m00 or m11) then
            i = 2
        end
        if i == 0 then
            local s = math.sqrt(m00 - m11 - m22 + 1)
            local recip = 0.5 / s
            return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
        elseif i == 1 then
            local s = math.sqrt(m11 - m22 - m00 + 1)
            local recip = 0.5 / s
            return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
        elseif i == 2 then
            local s = math.sqrt(m22 - m00 - m11 + 1)
            local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
        end
    end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
    local xs, ys, zs = x + x, y + y, z + z
    local wx, wy, wz = w * xs, w * ys, w * zs
    local xx = x * xs
    local xy = x * ys
    local xz = x * zs
    local yy = y * ys
    local yz = y * zs
    local zz = z * zs
    return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
    local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
    local startInterp, finishInterp;
    if cosTheta >= 0.0001 then
        if (1 - cosTheta) > 0.0001 then
            local theta = ACOS(cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((1 - t) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = 1 - t
            finishInterp = t
        end
    else
        if (1 + cosTheta) > 0.0001 then
            local theta = ACOS(-cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((t - 1) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
    end
    return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
 
function Clerp(a, b, t)
    local qa = {QuaternionFromCFrame(a)}
    local qb = {QuaternionFromCFrame(b)}
    local ax, ay, az = a.x, a.y, a.z
    local bx, by, bz = b.x, b.y, b.z
    local _t = 1 - t
    return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end


function MakeForm(PART,TYPE)
	local MSH = nil
    if TYPE == "Cyl" then
        MSH = IT("CylinderMesh",PART)
    elseif TYPE == "Ball" then
        MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Sphere"
    elseif TYPE == "Wedge" then
        MSH = IT("SpecialMesh",PART)
        MSH.MeshType = "Wedge"
    end
	return MSH
end

function Damage(Hum,Damage)
	local DEAD = false
		
	if Hum.Health < 2000 then
		if Hum.Health - Damage > 0 then
			Hum.Health = Hum.Health - Damage
		else
			DEAD = true
			Hum.Parent:BreakJoints()
		end
	else
		Hum.Parent:BreakJoints()
		DEAD = true
	end
	
	return DEAD
end
	
function GetNearest(Position, Distance)
	local Return = {}
	
	for _,c in pairs(workspace:GetDescendants()) do
		if c:IsA("Model") then
			if c ~= Character and not c:IsDescendantOf(Character) then
				if c:FindFirstChildOfClass("Humanoid") then
					local Head = c:FindFirstChild("Head")
				
					if Head then
						if Distance >= (Head.Position - Position).Magnitude then
							table.insert(Return,c)
						end
					end
				end
			end
		end
	end
	return Return
end

function ApplyAOE(Position,Range,Damage)
	for _,c in pairs(GetNearest(Position,Range)) do
		local Hum = c:FindFirstChildOfClass("Humanoid")
		
		if Hum then
			if Damage < math.huge then
				Damage(Hum,Damage)
			else
				Hum.Parent:BreakJoints()
			end
		end
	end
end

function PlayAnim(SPEED, CHARSIZE, TABLE)
	local NeckCF = TABLE[1]
	local RootJointCF = TABLE[2]
	local RSCF = TABLE[3]
	local LSCF = TABLE[4]
	local RHCF = TABLE[5]
	local LHCF = TABLE[6]

	do
		local x, y, z, m11, m12, m13, m21, m22, m23, m31, m32, m33 = NeckCF:components()
		Joints.Neck.C0 = Clerp(Joints.Neck.C0, CF(0 * CHARSIZE, 1 * CHARSIZE, 0 * CHARSIZE, -1, 0, 0, 0, 0, 1, 0, 1, -0), SPEED)
		Joints.Neck.C1 = Clerp(Joints.Neck.C1, CF(x * CHARSIZE, y * CHARSIZE, z * CHARSIZE, m11, m12, m13, m21, m22, m23, m31, m32, m33), SPEED)
	end
	do
		local x, y, z, m11, m12, m13, m21, m22, m23, m31, m32, m33 = RootJointCF:components()
		Joints.Root.C0 = Clerp(Joints.Root.C0, CF(0 * CHARSIZE, 0 * CHARSIZE, 0 * CHARSIZE, -1, 0, 0, 0, 0, 1, 0, 1, -0), SPEED)
		Joints.Root.C1 = Clerp(Joints.Root.C1, CF(x * CHARSIZE, y * CHARSIZE, z * CHARSIZE, m11, m12, m13, m21, m22, m23, m31, m32, m33), SPEED)
	end
	do
		local x, y, z, m11, m12, m13, m21, m22, m23, m31, m32, m33 = RSCF:components()
		Joints.RS.C0 = Clerp(Joints.RS.C0, CF(1 * CHARSIZE, 0.5 * CHARSIZE, 0 * CHARSIZE, 0, 0, 1, 0, 1, -0, -1, 0, 0), SPEED)
		Joints.RS.C1 = Clerp(Joints.RS.C1, CF(x * CHARSIZE, y * CHARSIZE, z * CHARSIZE, m11, m12, m13, m21, m22, m23, m31, m32, m33), SPEED)
	end
	do
		local x, y, z, m11, m12, m13, m21, m22, m23, m31, m32, m33 = LSCF:components()
		Joints.LS.C0 = Clerp(Joints.LS.C0, CF(-1 * CHARSIZE, 0.5 * CHARSIZE, 0 * CHARSIZE, 0, 0, -1, 0, 1, 0, 1, 0, 0), SPEED)
		Joints.LS.C1 = Clerp(Joints.LS.C1, CF(x * CHARSIZE, y * CHARSIZE, z * CHARSIZE, m11, m12, m13, m21, m22, m23, m31, m32, m33), SPEED)
	end
	do
		local x, y, z, m11, m12, m13, m21, m22, m23, m31, m32, m33 = RHCF:components()
		Joints.RH.C0 = Clerp(Joints.RH.C0, CF(1 * CHARSIZE, -1 * CHARSIZE, 0 * CHARSIZE, 0, 0, 1, 0, 1, -0, -1, 0, 0), SPEED)
		Joints.RH.C1 = Clerp(Joints.RH.C1, CF(x * CHARSIZE, y * CHARSIZE, z * CHARSIZE, m11, m12, m13, m21, m22, m23, m31, m32, m33), SPEED)
	end
	do
		local x, y, z, m11, m12, m13, m21, m22, m23, m31, m32, m33 = LHCF:components()
		Joints.LH.C0 = Clerp(Joints.LH.C0, CF(-1 * CHARSIZE, -1 * CHARSIZE, 0 * CHARSIZE, 0, 0, -1, 0, 1, 0, 1, 0, 0), SPEED)
		Joints.LH.C1 = Clerp(Joints.LH.C1, CF(x * CHARSIZE, y * CHARSIZE, z * CHARSIZE, m11, m12, m13, m21, m22, m23, m31, m32, m33), SPEED)
	end
end

function Tween(Part, Prop, Style, Direction, Time, Callback)
	local Dir = Enum.EasingDirection[Direction]
	local Stylist = Enum.EasingStyle[Style]
	
	local Tween = Ser.TS:Create(Part, TweenInfo.new(Time, Stylist, Dir), Prop)
	Tween:Play()
	
	Tween.Completed:Connect(function()
		if Callback then
			coroutine.wrap(Callback)()
		end
	end)
end

function Effect(Data)
	local Type = Data.EffectType or "Sphere"
	local Size = Data.Size or VT(1,1,1)
	local EndSize = Data.Size2 or VT(0,0,0)
	local Trans = Data.Trans or 0
	local EndTrans = Data.Trans2 or 1
	local C = Data.CFrame or Body.Torso.CFrame
	local MoveTo = Data.MoveToPos or Body.Torso.CFrame
	local Rot1 = Data.RotationX or 0
	local Rot2 = Data.RotationY or 0
	local Rot3 = Data.RotationZ or 0
	local Material = Data.Material or "Neon"
	local Color = Data.Color or C3(1,1,1)
	local EndColor = Data.Color2 or Color
	local Time = Data.Time or 1
	local SEId = Data.SoundId or nil
	local SEPitch = Data.Pich or nil
	local SEVolume = Data.Volume or nil
	
	coroutine.wrap(function()
		local PlaySound = false
		local SE = nil
		local EFFECT = Part(Material,Color,VT(1,1,1),Effects,0,Trans,"Effect",true)
		EFFECT.CanCollide = false
		EFFECT.CFrame = C
		
		if SEId and SEPitch and SEVolume then
			PlaySound = true
			SE = Sound(SEId,EFFECT,SEVolume,SEPitch,false)
		end
		
		local MSH = nil
		
		if Type == "Block" or Type == "Box" then
			MSH = New("BlockMesh",EFFECT,{Scale = VT(Size.X,Size.X,Size.X)})
		elseif Type == "Sphere" then
			MSH = Mesh("SpecialMesh",EFFECT,"Sphere","","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Wave" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","20329976","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Ring" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","559831844","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Slash" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","662586858","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Round Slash" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","662585058","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Swirl" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","1051557","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Skull" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","4770583","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Crystal" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","9756362","",VT(1,1,1),VT(0,0,0))
		elseif Type == "Crown" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","173770780","",VT(1,1,1),VT(0,0,0))
		elseif Type == "DullRing" then
			MSH = Mesh("SpecialMesh",EFFECT,"FileMesh","3270017","",VT(1,1,1),VT(0,0,0))
		end
		
		if MSH then
			MSH.Scale = Size
			
			Tween(EFFECT,{Transparency = EndTrans,CFrame = EFFECT.CFrame * ANGLES(RAD(Rot1),RAD(Rot2),RAD(Rot3)),Color = EndColor},"Linear","InOut",Time)
			Tween(MSH,{Scale = EndSize},"Linear","InOut",Time,function()
				if not PlaySound then
					Ser.Debris:AddItem(EFFECT,2)
				else
					coroutine.wrap(function()
						repeat wait() until SE.Playing == false Ser.Debris:AddItem(EFFECT,0.2)
					end)()
				end
			end)
		end
	end)()
end

function Lightning(p0,p1,timee,ofs,color,th,tra,last)
	local magz = (p0 - p1).Magnitude
	local curpos = p0
	local trz = {-ofs,ofs}
	
	for i = 1,timee do
		local li = Part("Neon",color,VT(th,th,magz / timee), Effects, 0, 0, "Effekt", true) li.CanCollide = false
		local ofz = VT(trz[RANDOM(1,#trz)],trz[RANDOM(1,#trz)],trz[RANDOM(1,#trz)])
		local magz2 = (curpos - p1).Magnitude
		local trolpos = CF(curpos, p1) * CF(0, 0, magz / timee).p + ofz
		
		if timee == i then
			local magz2 = (curpos - p1).Magnitude
            li.Size = VT(th, th, magz2)
            li.CFrame = CF(curpos, p1) * CF(0, 0, -magz2 / 2)
            Tween(li,{Transparency = 1},"Linear","InOut",last,function()
				Ser.Debris:AddItem(li,0.5)
			end)
		else
			li.CFrame = CFrame.new(curpos, trolpos) * CFrame.new(0, 0, magz / timee / 2)
            curpos = li.CFrame * CFrame.new(0, 0, magz / timee / 2).p
            game.Debris:AddItem(li, 10)
 			Tween(li,{Transparency = 1},"Linear","InOut",last,function()
				Ser.Debris:AddItem(li,0.5)
			end)
		end
	end
end

--// CUSTOMIZATION \\--
local Portal = script.Portal:Clone()
script.Portal:Destroy()

local Entity = script.Entity:Clone()
script.Entity:Destroy()

local BodyColors = Character:WaitForChild("Body Colors")
pcall(game.Destroy, Character.Animate)
local Songs = {608726256,2046300928,340286845}
local MusicInt = Random.new():NextInteger(1,#Songs)

local Cosmetics = New("Folder",Character,{Name = "Cosmetics"})

local Face = New("Decal",Body.Head,{Texture = "rbxassetid://2463689512"})

local Horn1 = script.Horn1
local Horn2 = script.Horn2
local Wings = script.Wings

Horn1.Parent = Cosmetics
Horn2.Parent = Cosmetics
Wings.Parent = Cosmetics

local Horn2Weld = CustomWeld(Body.Head,Horn2,CF(-1,1.3,0) * ANGLES(RAD(0),RAD(0),RAD(-20)),CF())
local Horn1Weld = CustomWeld(Body.Head,Horn1,CF(0.9,0.55,0) * ANGLES(RAD(0),RAD(180),RAD(30)),CF())
local WingsWeld = CustomWeld(Body.Torso,Wings.Handle,CF(0,0.55,0.6) * ANGLES(RAD(0),RAD(180),RAD(0)),CF())
local Lite = New("PointLight",Body.Torso,{Brightness = 7.5,Color = C3(1,0,1/100),Range = 8,Shadows = true})

local RightWingWeld = Wings.RightWing.RightWing
local LeftWingWeld = Wings.LeftWing.LeftWing

local Pt1 = script.Pt1
local Pt2 = script.Pt2
Pt1.Enabled = true
Pt2.Enabled = true
Pt1.Parent = Body.Torso
Pt2.Parent = Body.Torso

local Nametag = script.Nametag
Nametag.Parent = Body.Torso
Nametag.Adornee = Body.Torso
--[[
Character["Head"].Color = BRICKC("Really black").Color
Character["Torso"].Color = BRICKC("Really black").Color
Character["Right Arm"].Color = BRICKC("Really black").Color
Character["Left Arm"].Color = BRICKC("Really black").Color
Character["Right Leg"].Color = BRICKC("Really black").Color
Character["Left Leg"].Color = BRICKC("Really black").Color
]]
BodyColors.HeadColor3 = C3(1/17,1/17,1/17)
BodyColors.TorsoColor3 = C3(1/17,1/17,1/17)
BodyColors.RightArmColor3 = C3(1/17,1/17,1/17)
BodyColors.LeftArmColor3 = C3(1/17,1/17,1/17)
BodyColors.RightLegColor3 = C3(1/17,1/17,1/17)
BodyColors.LeftLegColor3 = C3(1/17,1/17,1/17)
--// FAKE BODY CREATION \\--
local FakePartsHolder = New("Folder",Character,{Name = "FakeParts"})

for i,v in pairs(Body) do
	if v.Name ~= "Head" then
		local Mesh = script.Mesh:Clone()
		Mesh.Parent = v
	end
end

for i,v in pairs(script.FakeParts:GetChildren()) do
	if Character:FindFirstChild(v.Name) then
		local Part = Character:FindFirstChild(v.Name)
		
		v.Name = "Fake".. Part.Name
		string.gsub(v.Name," ","",MHUGE)
		CustomWeld(Part,v,CF(),CF())
		v.Parent = FakePartsHolder
	end
end

Body.Torso.Mesh.MeshId = "rbxasset://fonts/torso.mesh"
Body.Head.Mesh.Scale = VT(1.25, 1.25, 1.25)
Body.Torso.Mesh.Scale = VT(0.92, 0.92, 0.92)
Body.RA.Mesh.Scale = VT(0.9, 0.9, 0.9)
Body.LA.Mesh.Scale = VT(0.9, 0.9, 0.9)
Body.RL.Mesh.Scale = VT(0.9, 0.9, 0.9)
Body.LL.Mesh.Scale = VT(0.9, 0.9, 0.9)


--// INTRO \\--
local SICK = Sound(Songs[MusicInt],Body.Torso,5,1,true)

do
	ATTACK = true
	
	local PORTAL = Portal:Clone()
	Body.RootPart.Anchored = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 0
	
	for i,v in pairs(PORTAL:GetChildren()) do
		v.Transparency = 1
		Tween(v,{Transparency = 0},"Linear","InOut",1)
	end
	
	PORTAL.Parent = Effects
	PORTAL:SetPrimaryPartCFrame(Body.RootPart.CFrame * CF(0,-2.5,0) * ANGLES(RAD(90),RAD(0),RAD(0)))
	Joints.Root.C1 = CF(0, 12, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
		
	local Val = New("CFrameValue",nil,{Value = PORTAL:GetPrimaryPartCFrame()})
		
	coroutine.wrap(function()
		local ANGLE = 0
		while PORTAL.Parent do
			ANGLE = ANGLE + 0.1
			Swait()
			Val.Value = Val.Value * ANGLES(RAD(0),RAD(0),RAD(ANGLE))
		end
	end)()

	local E = Val:GetPropertyChangedSignal("Value"):Connect(function()
		PORTAL:SetPrimaryPartCFrame(Val.Value)
	end)
	
	Tween(Joints.Neck,{C1 = CF(0, -0.500000954, 0, -0.939692616, 0, -0.342020154, -0.342020154, 0, 0.939692616, 0, 1, 0)},"Linear","InOut",0.1)
	--Tween(Joints.Root,{C1 = CF(0, -4, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)},"Sine","InOut",0.5)
	Tween(Joints.RS,{C1 = CF(-0.5, 0.5, 0, 0, 0.642787576, 0.766044438, 0, 0.766044438, -0.642787576, -1, 0, 0)},"Linear","InOut",0.1)
	Tween(Joints.LS,{C1 = CF(0.5, 0.5, 0, 0, -0.642787576, -0.766044438, 0, 0.766044438, -0.642787576, 1, 0, 0)},"Linear","InOut",0.1)
	Tween(Joints.RH,{C1 = CF(0.5, 0.437385559, 0.0985031128, 0, 0, 1, 0.342019975, 0.939692676, 0, -0.939692676, 0.342019975, 0)},"Linear","InOut",0.1)
	Tween(Joints.LH,{C1 = CF(-0.5, 0.879887581, 0.0889434814, 0, 0, -1, -0.258819044, 0.965925813, 0, 0.965925813, 0.258819044, 0)},"Linear","InOut",0.1)
	
	wait(2)
	Tween(Joints.Root,{C1 = CF(0, -4, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)},"Sine","InOut",2,function()
		wait(1)
		for i,v in pairs(PORTAL:GetChildren()) do
			Tween(v,{Transparency = 1},"Linear","InOut",1)
		end
		E:Disconnect()
		Ser.Debris:AddItem(PORTAL,3)
		Body.RootPart.Anchored = false
		Humanoid.WalkSpeed = 16
		Humanoid.JumpPower = 50
		ATTACK = false
	end)
	
end
--// END OF CUSTOMIZATION \\--

--// ATTACK FUNCTIONS \\--

function Corrupt_Stomp()
	ATTACK = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 0
	
	repeat Swait() 
		Effect({EffectType = "Round Slash";Size = VT(0.05,0.01,0.05);Size2 = VT(0,0,0);Trans = 1;Trans2 = 0;CFrame = Body.LL.CFrame * ANGLES(RAD(RANDOM(-360,360)),RAD(RANDOM(-360,360)),RAD(RANDOM(-360,360)));Color = C3(1,0,1/100);})
		
		PlayAnim(1 / 3, 1, {
			CF(0, -0.5, 0, -1, 0, 0, 0, 0.17364797, 0.984807789, 0, 0.984807789, -0.17364797);
			CF(0, 0, 0, -1, 0, 0, 0, 0.17364797, 0.984807789, 0, 0.984807789, -0.17364797);
			CF(-0.5, 0.500005722, -1.90734863e-06, -0.0858314633, 0.0151343867, 0.99619472, -0.704957366, -0.707485795, -0.0499903858, 0.70403713, -0.70656538, 0.0713936388);
			CF(0.5, 0.5, 0, 0, 0, -1, 0.707106769, -0.707106769, 0, -0.707106769, -0.707106769, -0);
			CF(0.5, 1.00000191, -1.90734863e-05, 0, 0, 1, 0.258819401, 0.965925753, 0, -0.965925753, 0.258819401, 0);
			CF(-0.5, 0.540739059, 0.434833527, 0, 0, -1, 0.422617853, 0.906307936, 0, 0.906307936, -0.422617853, 0);
		})
	until KEYHOLD == false
	
	Tween(Joints.Neck,{C1 = CF(0, -0.5, -5.7220459e-06, -1, 0, 0, 0, -0.17364797, 0.984807789, 0, 0.984807789, 0.17364797)},"Linear","InOut",0.1)
	Tween(Joints.Root,{C1 = CF(0, 0, 0, -1, 0, 0, 0, -0.342020363, 0.939692557, 0, 0.939692557, 0.342020363)},"Linear","InOut",0.1)
	Tween(Joints.RS,{C1 = CF(-0.5, 0.500001907, -5.7220459e-06, 0, 0, 1, 0.42261833, 0.906307817, 0, -0.906307817, 0.42261833, 0)},"Linear","InOut",0.1)
	Tween(Joints.LS,{C1 = CF(0.5, 0.5, -3.81469727e-06, 0, 0, -1, -0.422618389, 0.906307697, 0, 0.906307697, 0.422618389, 0)},"Linear","InOut",0.1)
	Tween(Joints.RH,{C1 = CF(0.5, 1.1638279, 0.114715576, 0, 0, 1, 0.258818954, 0.965925872, 0, -0.965925872, 0.258818954, 0)},"Linear","InOut",0.1)
	Tween(Joints.LH,{C1 = CF(-0.5, 0.956422806, 0.498104095, 0, 0, -1, 0.258819044, 0.965925872, 0, 0.965925872, -0.258819044, 0)},"Linear","InOut",0.1)
	
	wait(0.1)
	
	local Charge = Sound(1620566047,Body.Torso,5,1,true)
	coroutine.wrap(function()
		repeat wait() until KEYHOLD == false
		Ser.Debris:AddItem(Charge,0)
	end)()
	
	Sound(1539349118,Body.Torso,5,1,false)
	local Multiply = 0
	for i = 1,10 do
		Multiply = Multiply + 2
		ApplyAOE(Body.RootPart.Position, 20 * Multiply,math.huge)
		RS:Wait()
		Effect({CFrame = Body.RootPart.CFrame;EffectType = "Wave";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);RotationY = RANDOM(-360,360);Color = MainColor})
		Effect({CFrame = Body.RootPart.CFrame;EffectType = "Wave";Time = 1;Size = VT(0,0,0);Size2 = VT(25 * Multiply,2,25 * Multiply);RotationY = RANDOM(-360,360);Color = MainColor})
		Effect({CFrame = Body.RootPart.CFrame;EffectType = "Sphere";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);Color = MainColor})
		Effect({CFrame = Body.RootPart.CFrame;EffectType = "Round Slash";Time = 1.5;Size = VT(0,0,0);Size2 = VT(4,4,4);RotationX = RANDOM(-360,360);Color = MainColor;Trans = 0.5})
		Effect({CFrame = Body.RootPart.CFrame;EffectType = "Swirl";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);RotationY = RANDOM(-90,90);Color = MainColor})
	end
	
	ATTACK = false
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 50
end

function Aura_Throw()
	ATTACK = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 0
	
	Tween(Joints.Neck,{C1 = CF(0, -0.500000954, 0, -0.939692616, 0, -0.342020154, -0.342020154, 0, 0.939692616, 0, 1, 0)},"Linear","InOut",0.1)
	Tween(Joints.Root,{C1 = CF(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)},"Linear","InOut",0.1)
	Tween(Joints.RS,{C1 = CF(-0.500003815, 0.5, 1.90734863e-06, 0.342020363, 0, 0.939692557, -0.88302213, 0.342020094, 0.321393996, -0.321393728, -0.939692616, 0.116977833)},"Linear","InOut",0.1)
	Tween(Joints.LS,{C1 = CF(0.500003815, 0.5, 2.86102295e-06, 0.342020363, 0, -0.939692557, 0.88302213, 0.342020094, 0.321393996, 0.321393728, -0.939692616, 0.116977833)},"Linear","InOut",0.1)
	Tween(Joints.RH,{C1 = CF(0.5, 0.437385559, 0.0985031128, 0, 0, 1, 0.342019975, 0.939692676, 0, -0.939692676, 0.342019975, 0)},"Linear","InOut",0.1)
	Tween(Joints.LH,{C1 = CF(-0.5, 0.879887581, 0.0889434814, 0, 0, -1, -0.258819044, 0.965925813, 0, 0.965925813, 0.258819044, 0)},"Linear","InOut",0.1)
	
	coroutine.wrap(function()
		for i = 1,100 do
			local HIT,POS = CastProperRay(Body.RootPart.Position, Body.RootPart.Position - VT(0,999,0),9999,Character)
			Swait(2)
			Effect({Time = 0.5;CFrame = Body.RootPart.CFrame;Size = VT(0,0,0);Trans = 0.7;Size2 = VT(25,25,25);EffectType = "Swirl";RotationY = RANDOM(-360,360);Color = MainColor})
			Effect({Time = 0.5;CFrame = CF(POS) * CF(0,0.3,0);Size = VT(0,0,0);Size2 = VT(25,0,25);EffectType = "Wave";RotationY = RANDOM(-360,360);Color = MainColor})
		end
	end)()
	
	local Balwz = Part("Neon",MainColor,VT(0,0,0),Effects,0,0,"Balwz",true) MakeForm(Balwz,"Ball") Balwz.CanCollide = false Balwz.CFrame = Body.Torso.CFrame * CF(0,0,-1)
	local Charge = Sound(1382718007,Body.RootPart,5,1,false)
	
	Tween(Balwz,{Size = VT(1.5,1.5,1.5)},"Linear","InOut",3,function()
		Sound(1619519574,Body.Torso,5,1,false)
		Ser.Debris:AddItem(Charge,0)
		
		Tween(Joints.Neck,{C1 = CF(0, -0.5, 7.62939453e-06, -1, 0, 0, 0, 0.0871557444, 0.996194661, 0, 0.996194661, -0.0871557444)},"Linear","InOut",0.1)
		Tween(Joints.Root,{C1 = CF(0, 0, 0, -1, 0, 0, 0, 0.258819282, 0.965925753, 0, 0.965925753, -0.258819282)},"Linear","InOut",0.1)
		Tween(Joints.RS,{C1 = CF(-0.500001192, 0.499997795, 4.78327274e-06, 0.77101028, -0.60298574, 0.204819262, -0.3838543, -0.183412746, 0.904994845, -0.508132458, -0.776381075, -0.372871965)},"Linear","InOut",0.1)
		Tween(Joints.LS,{C1 = CF(0.5, 0.500001907, -1.90734863e-06, 0, 0, -1, -0.422618091, -0.906307817, -0, -0.906307817, 0.422618091, 0)},"Linear","InOut",0.1)
		Tween(Joints.RH,{C1 = CF(0.5, 0.999997139, 7.59959221e-06, 0, 0, 1, 0.342019588, 0.939692557, 0, -0.939692557, 0.342019588, 0)},"Linear","InOut",0.1)
		Tween(Joints.LH,{C1 = CF(-0.5, 0.728106499, 0.126789093, 0, 0, -1, 0.173647985, 0.984807611, 0, 0.984807611, -0.173647985, 0)},"Linear","InOut",0.1)
		Tween(Balwz,{CFrame = Body.LA.CFrame * CF(0.8,3,-1.2)},"Linear","InOut",0.1)
		
		wait(0.3)
		Tween(Joints.Neck,{C1 = CF(0, -0.5, 0, -1, 0, 0, 0, -0.17364797, 0.984807789, 0, 0.984807789, 0.17364797)},"Linear","InOut",0.1)
		Tween(Joints.Root,{C1 = CF(0, 0, 0, -1, 0, 0, 0, -0.258819044, 0.965925813, 0, 0.965925813, 0.258819044)},"Linear","InOut",0.1)
		Tween(Joints.RS,{C1 = CF(-0.49999997, 0.49999997, 0, 0.933012664, -0.25000003, 0.258819073, -0.25000003, 0.0669873133, 0.965925813, -0.258819073, -0.965925813, 0)},"Linear","InOut",0.1)
		Tween(Joints.LS,{C1 = CF(0.5, 0.49999994, 2.98023224e-08, 0, 0, -0.99999994, 0.707107127, -0.707106471, 0, -0.707106471, -0.707107127, -0)},"Linear","InOut",0.1)
		Tween(Joints.RH,{C1 = CF(0.5, 0.999997139, 7.59959221e-06, 0, 0, 1, 0.342019588, 0.939692557, 0, -0.939692557, 0.342019588, 0)},"Linear","InOut",0.1)
		Tween(Joints.LH,{C1 = CF(-0.5, 0.728106499, 0.126789093, 0, 0, -1, 0.173647985, 0.984807611, 0, 0.984807611, -0.173647985, 0)},"Linear","InOut",0.1)
		Balwz.CFrame = CF(Balwz.Position,Mouse.Hit.Position)
		Balwz.Anchored = false
		local BV = New("BodyVelocity",Balwz,{MaxForce = HUGE;Velocity = Balwz.CFrame.LookVector * 200})
		local C = nil
		C = Balwz.Touched:Connect(function(Hit)
			if not Hit:IsDescendantOf(Character) then
				C:Disconnect()
				Sound(379698301,Body.Torso,10,1,false)
				Sound(605005842,Body.Torso,5,1,false)
				Sound(439342426,Body.Torso,10,1,false)
				Ser.Debris:AddItem(Balwz,0)
				local Multiply = 0
				for i = 1,10 do
					Multiply = Multiply + 2
					ApplyAOE(Balwz.Position,20 * Multiply,MHUGE)
					RS:Wait()
					Effect({CFrame = CF(Balwz.Position);EffectType = "Swirl";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);RotationY = RANDOM(-90,90);Color = MainColor})
					Effect({CFrame = CF(Balwz.Position);EffectType = "Wave";Time = 1;Size = VT(0,0,0);Size2 = VT(25 * Multiply,2,25 * Multiply);RotationY = RANDOM(-360,360);Color = MainColor})
					Effect({CFrame = Balwz.CFrame;EffectType = "Sphere";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);Color = MainColor})
				end
			end
		end)
		
		ATTACK = false
		Humanoid.WalkSpeed = 16
		Humanoid.JumpPower = 50
	end)
end

function Internet_Summon()
	ATTACK = true
	Body.RootPart.Anchored = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 0
	
	Tween(Joints.Neck,{C1 = CF(0, -0.500000954, 0, -0.939692616, 0, -0.342020154, -0.342020154, 0, 0.939692616, 0, 1, 0)},"Linear","InOut",0.1)
	Tween(Joints.Root,{C1 = CF(0, -4, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)},"Sine","InOut",0.5)
	Tween(Joints.RS,{C1 = CF(-0.5, 0.5, 0, 0, 0.642787576, 0.766044438, 0, 0.766044438, -0.642787576, -1, 0, 0)},"Linear","InOut",0.1)
	Tween(Joints.LS,{C1 = CF(0.5, 0.5, 0, 0, -0.642787576, -0.766044438, 0, 0.766044438, -0.642787576, 1, 0, 0)},"Linear","InOut",0.1)
	Tween(Joints.RH,{C1 = CF(0.5, 0.437385559, 0.0985031128, 0, 0, 1, 0.342019975, 0.939692676, 0, -0.939692676, 0.342019975, 0)},"Linear","InOut",0.1)
	Tween(Joints.LH,{C1 = CF(-0.5, 0.879887581, 0.0889434814, 0, 0, -1, -0.258819044, 0.965925813, 0, 0.965925813, 0.258819044, 0)},"Linear","InOut",0.1)
	
	local PORTAL = Portal:Clone()
	PORTAL.Parent = Effects
	PORTAL:SetPrimaryPartCFrame(Body.RootPart.CFrame * CF(0,-10,0))
	
	local Val = New("CFrameValue",nil,{Value = PORTAL:GetPrimaryPartCFrame()})
	Tween(Val,{Value = Body.Torso.CFrame * CF(0,-5,0) * ANGLES(RAD(90),RAD(0),RAD(0))},"Sine","InOut",1)
	
	delay(0,function()
		local ANGLE = 0
		while PORTAL.Parent do
			ANGLE = ANGLE + 0.1
			Swait()
			Val.Value = Val.Value * ANGLES(RAD(0),RAD(0),RAD(ANGLE))
		end
	end)
	
	delay(2,function()
		Tween(Joints.Root,{C1 = CF(0, 12, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)},"Sine","InOut",0.5)
	end)
	local E = Val:GetPropertyChangedSignal("Value"):Connect(function()
		PORTAL:SetPrimaryPartCFrame(Val.Value)
	end)
	
	wait(3)
	for i = 1,10 do
		wait(RANDOM(0.5,1))
		local NEAREST = GetNearest(PORTAL.PrimaryPart.Position, 100)
		local E = NEAREST[Random.new():NextInteger(1,#NEAREST)]
		
		if #NEAREST <= 0 then break end
		local E_HUM = E:FindFirstChildOfClass("Humanoid") 
		if not E_HUM or E_HUM.Health <= 0 then break end
		
		local ENTITY = Entity:Clone()
		ENTITY.Parent = Effects
		local ENT_HUM = ENTITY.Humanoid
		local ROOT = ENTITY.HumanoidRootPart
		
		ROOT.Anchored = true
		ROOT.CFrame = Body.RootPart.CFrame * CF(RANDOM(-3,3),0.2,RANDOM(-3,3)) * ANGLES(RAD(0),RAD(RANDOM(-360,360)),RAD(0))
		
		local PILLAR = Part("Neon",MainColor,VT(5,100,5),Effects,0,0,"Pillar",true) PILLAR.CanCollide = false PILLAR.CFrame = ROOT.CFrame Tween(PILLAR,{Size = VT(0,100,0);Transparency = 1},"Linear","InOut",1)
		MakeForm(PILLAR,"Cyl")
		ROOT.Anchored = false
		
		coroutine.wrap(function()
			ENT_HUM:MoveTo(E.Head.Position)
			ENT_HUM.MoveToFinished:Connect(function()
				ApplyAOE(ROOT.Position,10,MHUGE)
				Effect({Time = 0.5;CFrame = ROOT.CFrame * CF(0,-1,0);EffectType = "Wave";Color = MainColor;Size = VT(0,0,0);Size2 = VT(25,0,25);RotationY = RANDOM(-360,360)})
				for i = 1,20 do
					Effect({Time = 0.5;CFrame = ROOT.CFrame * ANGLES(RAD(RANDOM(0,360)), RAD(RANDOM(0,360)), RAD(RANDOM(0,360)));EffectType = "Wave";Color = MainColor;Size = VT(0,0,0);Size2 = VT(25,2,25);RotationY = RANDOM(-15,15) / 7.5})
					Effect({Time = 0.5;CFrame = ROOT.CFrame;EffectType = "Swirl";Size = VT(0,0,0);Size2 = VT(25,25,25);Trans = 0.5;RotationY = RANDOM(-90,90);Color = MainColor})
				end
				Ser.Debris:AddItem(ENTITY,0)
			end)
		end)()
	end
	
	E:Disconnect()
	Ser.Debris:AddItem(Val,0.0001)
	
	coroutine.wrap(function()
		Ser.Debris:AddItem(PORTAL,1.2)
		for i,v in pairs(PORTAL:GetChildren()) do
			Tween(v,{Transparency = 1},"Linear","InOut",1)
		end
	end)()
	
	ATTACK = false
	Body.RootPart.Anchored = false
	Humanoid.WalkSpeed = 16
	Humanoid.JumpPower = 50
end

function Teleport()
	if not Mouse.Target then return end
	Sound(1894958339,Body.RootPart,10,1,false)
	
	local ATTACK = true
	local PILLAR = Part("Neon",MainColor,VT(15,100,15),Effects,0,0,"Pillar",true) PILLAR.CanCollide = false PILLAR.CFrame = Body.RootPart.CFrame Tween(PILLAR,{Size = VT(0,100,0);Transparency = 1},"Linear","InOut",1) Ser.Debris:AddItem(PILLAR,3)
	Effect({Time = 0.5;EffectType = "Swirl";Size = VT(0,0,0);Size2 = VT(15,100,15);Color = MainColor;CFrame = Body.RootPart.CFrame})
	MakeForm(PILLAR,"Cyl")
	
	Body.RootPart.CFrame = Mouse.Hit * CF(0,4,0)
	local PILLAR = Part("Neon",MainColor,VT(15,100,15),Effects,0,0,"Pillar",true) PILLAR.CanCollide = false PILLAR.CFrame = Body.RootPart.CFrame Tween(PILLAR,{Size = VT(0,100,0);Transparency = 1},"Linear","InOut",1) Ser.Debris:AddItem(PILLAR,3)
	MakeForm(PILLAR,"Cyl")
	wait(0.1)
	ATTACK = false
end

function Horn()
	if not Mouse.Target then return end
	ATTACK = true
	local POS = Mouse.Hit
	Horn2.Transparency = 1
	
	local FakeHorn = Horn2:Clone()
	FakeHorn.Anchored = true
	FakeHorn.CFrame = CF(Horn2.Position,POS.Position)
	FakeHorn.Transparency = 0
	FakeHorn.Parent = Effects
	
	local D 
	D = FakeHorn.Touched:Connect(function(HIT)
		if not HIT:IsDescendantOf(Character) then
			local HUM = HIT.Parent:FindFirstChildOfClass("Humanoid")
			
			if HUM then
				for i = 1,6 do
					Effect({Time = 0.3;EffectType = "Sphere";Color = MainColor;Material = "Neon";Size = VT(0.2,5,0.2);Size2 = VT(1,10,1);CFrame = FakeHorn.CFrame * ANGLES(RAD(RANDOM(-360,360)),RAD(0),RAD(RANDOM(-360,360)))})
				end
				HUM.Parent:BreakJoints()
				Sound(HITPLAYERSOUNDS[RANDOM(1,#HITPLAYERSOUNDS)],HUM,6,RANDOM(8,12)/10,false)
				for i,v in pairs(HUM.Parent:GetChildren()) do
					if v:IsA("BasePart") then
						v.Anchored = false
					end
				end
			end
			D:Disconnect()
		end
	end)
	
	local At1 = IT("Attachment",Body.LA)
	At1.Position = VT(0,-1,0)
	local At2 = IT("Attachment",FakeHorn)
	local Chain = New("Beam",Body.LA,{Color = ColorSequence.new(C3(1,0,1/200));Attachment0 = At1;Attachment1 = At2;Texture = "rbxassetid://73042633";TextureMode = "Static";Transparency = 0;TextureLength = 5;Width = 2;Width1 = 2})
	
	Tween(Joints.LS,{C1 = CF(.5, 0.5, 0, 0, 0, -1, 0.0525684245, -0.998617351, 0, -0.998617351, -0.0525684245, -0)},"Linear","InOut",0.1)
	Tween(FakeHorn,{CFrame = POS},"Sine","InOut",0.5,function()
		Tween(FakeHorn,{CFrame = Horn2.CFrame},"Sine","InOut",0.5,function()
			FakeHorn.Transparency = 1
			Horn2.Transparency = 0
			Ser.Debris:AddItem(FakeHorn,1)
			Ser.Debris:AddItem(Chain,0.1)
			Ser.Debris:AddItem(At1,0.1)
			Ser.Debris:AddItem(At2,0.1)
			ATTACK = false
		end)
	end)
end

function Corrupt_Force()
	if not Mouse.Target then return end
	local POS = Mouse.Hit
	
	ATTACK = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 0
	
	Tween(Joints.LS,{C1 = CF(.5, 0.5, 0, 0, 0, -1, 0.0525684245, -0.998617351, 0, -0.998617351, -0.0525684245, -0)},"Linear","InOut",0.3,function()
		for i = 1,100 do
			Swait(2)
			Effect({Color = MainColor;Time = 0.5;EffectType = "Sphere";Size = VT(0,0,0);Size2 = VT(1,4,1);CFrame = Body.LA.CFrame * CF(0,-1.5,0) * ANGLES(RAD(RANDOM(-360,360)),RAD(RANDOM(-360,360)),RAD(RANDOM(-360,360)))})
		end
		wait(1)
		for i = 1,3 do
			wait(0.65)
			Sound(852135845,Body.RootPart,10,1-(i/10),false)
			Effect({CFrame = POS;Time = 0.5;EffectType = "Sphere";Size = VT(0,0,0);Size2 = VT(35,35,35) + VT(i,i,i)*2;Color = MainColor;SoundId = 852135845;Pitch = 1-(i/10);Volume = 10})
		end
		wait(0.5)
		Sound(385545047, Body.RootPart, 2.5, 1.4, false)
		Sound(385545047, Body.RootPart, 2.5, 1, false)
		Sound(435742675, Body.RootPart, 2.5, 1.5, false)
		Sound(231917744, Body.RootPart, 2.5, 1.5, false)
		Sound(401056199, Body.RootPart, 2.5, 1, false)
		
		for i = 1,200 do
			ApplyAOE(POS.Position,150,MHUGE)
			Swait()
			Effect({Trans = 0.7;Time = 0.5;EffectType = "Swirl";Size = VT(0,600,0);Size = VT(50,600,50);Color = MainColor;CFrame = CF(POS.Position) * ANGLES(0,RAD(RANDOM(-360,360)),0)})
			Effect({Time = 0.5;EffectType = "Wave";Size = VT(50,25,50);Size2 = VT(250,25,250);Color = MainColor;CFrame = CF(POS.Position) * CF(0,1,0) * ANGLES(0,RAD(RANDOM(-360,360)),0)})
			Effect({Time = 0.5;EffectType = "Sphere";Size = VT(0,600,0);Size = VT(25,600,25);Color = MainColor;CFrame = CF(POS.Position);})
		end
		ATTACK = false
		Humanoid.WalkSpeed = 16
		Humanoid.JumpPower = 50
	end)
end

function Taunty()
	ATTACK = true
	local Taunt = Sound(907332040,Body.Torso,5,1,false)
	
	Tween(Joints.RS,{C1 = CF(-0.194000006, 0.650787354, 0.244194031, -0, -0.994983792, -0.100036077, -0.525400043, -0.0851162225, 0.846587241, -0.850855231, 0.052558966, -0.522764564)},"Linear","InOut",0.1)
	Tween(Joints.LS,{C1 = CF(0.501922607, 0.501167297, -0.0107688904, 0.973863006, 0.174731985, -0.145119295, 0.127931774, 0.105962455, 0.986106157, 0.187681496, -0.978897691, 0.0808391571)},"Linear","InOut",0.1)
	
	repeat Swait()
		PlayAnim(0.4 / 3, 1, {
			CF(0, -0.500000954, 0, -0.939692616, 0, -0.342020154, -0.342020154, 0, 0.939692616, 0, 1, 0) * ANGLES(RAD(5 * SIN(SINE / 12)),RAD(0),RAD(0));
			CF(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) * CF(0,0,0 + 0.1 * COS(SINE / 7));
			CF(-0.194000006, 0.650787354, 0.244194031, -0, -0.994983792, -0.100036077, -0.525400043, -0.0851162225, 0.846587241, -0.850855231, 0.052558966, -0.522764564);
			CF(0.501922607, 0.501167297, -0.0107688904, 0.973863006, 0.174731985, -0.145119295, 0.127931774, 0.105962455, 0.986106157, 0.187681496, -0.978897691, 0.0808391571);
			CF(0.5, 0.437385559, 0.0985031128, 0, 0, 1, 0.342019975, 0.939692676, 0, -0.939692676, 0.342019975, 0) * ANGLES(RAD(10 * COS(SINE / 7)),RAD(0),RAD(0));
			CF(-0.5, 0.879887581, 0.0889434814, 0, 0, -1, -0.258819044, 0.965925813, 0, 0.965925813, 0.258819044, 0) * ANGLES(RAD(5 * COS(SINE / 7)),RAD(0),RAD(0));
		})
	until Taunt.IsPlaying == false
	table.insert(ToDelet,Taunt)
	ATTACK = false
end

function Eternal_Doom()
	ATTACK = true
	Humanoid.WalkSpeed = 0
	Humanoid.JumpPower = 0
	
	local GYRO = New("BodyGyro",Body.RootPart,{MaxForce = HUGE,CFrame = Body.RootPart.CFrame})
	local BODYPOS = New("BodyPosition",Body.RootPart,{Name = "MoveFat";MaxForce = VT(MHUGE,MHUGE,MHUGE),Position = Body.RootPart.Position + VT(0,100,0)})
	Effect({EffectType = "Wave";CFrame = Body.RootPart.CFrame * CF(0,-3,0);Color = MainColor;Size = VT(0,0,0);Size2 = VT(25,4,25)})
	
	Tween(Joints.Neck,{C1 = CF(0, -0.499998093, 0, -1, 0, 0, 0, 0.588336468, 0.808616221, 0, 0.808616221, -0.588336468)},"Linear","InOut",0.1)
	wait(2)
	Tween(Joints.Neck,{C1 = CF(0, -0.5, 0, -1, 0, 0, 0, 0.464602023, 0.885519624, 0, 0.885519624, -0.464602023)},"Linear","InOut",0.1)
	Tween(Joints.Root,{C1 = CF(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -1)},"Sine","InOut",0.1)
	Tween(Joints.RS,{C1 = CF(-0.5, 0.5, 0, 0, 0, 1, 0.233239204, -0.972419381, 0, 0.972419381, 0.233239204, 0)},"Linear","InOut",0.1)
	Tween(Joints.LS,{C1 = CF(0.291769028, 0.617092133, 0.00705337524, -0.218659937, 0.439400464, -0.871272087, -0.441337109, 0.751803875, 0.489910841, 0.870292723, 0.491648555, 0.0295343623)},"Linear","InOut",0.1)
	Tween(Joints.RH,{C1 = CF(0.5, 0.437385559, 0.0985031128, 0, 0, 1, 0.342019975, 0.939692676, 0, -0.939692676, 0.342019975, 0)},"Linear","InOut",0.1)
	Tween(Joints.LH,{C1 = CF(-0.5, 0.879887581, 0.0889434814, 0, 0, -1, -0.258819044, 0.965925813, 0, 0.965925813, 0.258819044, 0)},"Linear","InOut",0.1)
	wait(0.1)
	
	local Growing = true
	
	coroutine.wrap(function()
		while Growing do
			Swait()
			Effect({EffectType = "Wave";CFrame = Body.RootPart.CFrame * CF(0,-3,0);Color = MainColor;Size = VT(0,0,0);Size2 = VT(25,4,25);RotationY = RANDOM(-360,360)})
		end
		Ser.Debris:AddItem(GYRO,0)
		Ser.Debris:AddItem(BODYPOS,0)
		Humanoid.WalkSpeed = 16
		Humanoid.JumpPower = 50
		ATTACK = false
	end)()
	
	local Ball = Part("Neon",Color3.fromRGB(255,0,200),VT(1,1,1),Effects,0,0,"Bawlz",true) Ball.CanCollide = false Ball.CFrame = Body.RA.CFrame
	local MSH = MakeForm(Ball,"Ball")
	Tween(Ball,{CFrame = Body.RA.CFrame * CF() * CF(0,-200,0)},"Sine","InOut",12)
	
	Tween(MSH,{Scale = VT(200,200,200)},"Sine","InOut",10,function()
		Growing = false
		local E1 = script.Big1:Clone()
		local E2 = script.Big2:Clone()
		E1.Parent = Ball
		E2.Parent = Ball
		E1.Enabled = true
		E2.Enabled = true
		wait(1)
		
		local POS = Mouse.Hit
		Ball.CFrame = CF(Ball.Position,POS.Position)
		local BV = New("BodyVelocity",Ball,{MaxForce = HUGE,Velocity = Ball.CFrame.LookVector * 20})
		Ball.Anchored = false
		local E 
		E = Ball.Touched:Connect(function()
			E:Disconnect()
			Ball.Anchored = true
			Ser.Debris:AddItem(Ball,1)
			local Multiply = 0
			for i = 1,5 do
				Multiply = Multiply + 3
				ApplyAOE(Ball.Position,20 * Multiply,MHUGE)
				Sound(439342426,Body.Torso,5,1,false)
				Sound(605005842,Body.Torso,5,1,false)
				Sound(565538688,Body.Torso,5,1,false)
				Sound(414517770,Body.Torso,5,1,false)
				for i = 1,10 do
					Effect({CFrame = CF(Ball.Position);EffectType = "Wave";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);RotationY = RANDOM(-360,360);Color = MainColor})
					Effect({CFrame = CF(Ball.Position);EffectType = "Wave";Time = 1;Size = VT(0,0,0);Size2 = VT(25 * Multiply,2,25 * Multiply);RotationY = RANDOM(-360,360);Color = MainColor})
					Effect({CFrame = CF(Ball.Position);EffectType = "Sphere";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);Color = MainColor})
					Effect({CFrame = CF(Ball.Position);EffectType = "Round Slash";Time = 1.5;Size = VT(0,0,0);Size2 = VT(4,4,4);RotationX = RANDOM(-360,360);Color = MainColor;Trans = 0.5})
					Effect({CFrame = CF(Ball.Position);EffectType = "Swirl";Time = 1.5;Size = VT(0,0,0);Size2 = VT(25 * Multiply,25 * Multiply,25 * Multiply);RotationY = RANDOM(-90,90);Color = MainColor})
				end
				wait(0.5)
			end
		end)
	end)
end
--// BINDING ATTACKS TO KEYS \\--
function MouseDown(Mouse)
	HOLD = true
end

function MouseUp(Mouse)
	HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	
	if ATTACK == false then
		if Key == "v" then
			Corrupt_Stomp()
		elseif Key == "z" then
			Aura_Throw()
		elseif Key == "g" then
			Internet_Summon()
		elseif Key == "t" then
			Teleport()
		elseif Key == "e" then
			Horn()
		elseif Key == "b" then
			Corrupt_Force()
		elseif Key == "r" then
			Taunty()
		elseif Key == "x" then
			Eternal_Doom()
		end
	end

	if Key == "m" then
		if SICK.IsPlaying == true then
			SICK:Pause()
		elseif SICK.IsPlaying == false then
			SICK:Resume()
		end
	elseif Key == "q" then
		MusicInt = MusicInt + 1
		if MusicInt > #Songs then MusicInt = 1 end
		SICK.SoundId = "rbxassetid://".. Songs[MusicInt]
		SICK:Play()
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

Mouse.Button1Down:Connect(function(NEWKEY)
	MouseDown(NEWKEY)
end)

Mouse.Button1Up:Connect(function(NEWKEY)
	MouseUp(NEWKEY)
end)

Mouse.KeyDown:Connect(function(NEWKEY)
	KeyDown(NEWKEY)
end)

Mouse.KeyUp:Connect(function(NEWKEY)
	KeyUp(NEWKEY)
end)
--// STARTING LOGIC \\--
local Regen = {}
delay(1,function()
	local Descendants = Character:GetDescendants()
	
	for i = 1,#Descendants do
		local E = Descendants[i]
		if E:IsA("BasePart") and not E:IsDescendantOf(Effects) then
			E.CustomPhysicalProperties = PhysicalProperties.new(Enum.Material.Wood)
			table.insert(Regen,{E,E.Parent,E.Color,E.Size,E.Material})
		end
		if E:IsA("JointInstance") then
			table.insert(Regen,{E,E.Parent,nil,nil,nil})
		end
	end
end)

for e = 1, #Regen do
	if Regen[e] ~= nil then
		local STUFF = Regen[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= Body.RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function Refit()
	for i = 1,#Regen do
		local E = Regen[i]
		local PART = E[1]
		local PARENT = E[2]
		local COLOR = E[3]
		local SIZE = E[4]
		local MATERIAL = E[5]
		
		if PART:IsA("BasePart") and PART.Parent ~= PARENT then
			PART.Color = COLOR
			PART.Size = SIZE
			PART.Material = MATERIAL
		end
		if PART.Parent ~= PARENT then
			Humanoid.Parent = nil
			PART.Parent = PARENT
			Humanoid.Parent = Character
		end
	end
	Humanoid.Parent = Character
end

Humanoid.Died:Connect(Refit)
Humanoid.HealthChanged:Connect(function()
	if Humanoid.Health <= 1 then
		Humanoid.Health = MHUGE
		Refit()
	end
end)

local States = {
	"FallingDown";
	"PlatformStanding";
	"Physics";
	"Swimming";
	"Dead";
	"Ragdoll";
	"Seated";
}
for i,v in pairs(States) do
	Humanoid:SetStateEnabled(v,false)
end

coroutine.wrap(function()
	while wait(2) do
		local Words = {"a","b",'c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',1,2,3,4,5,6,7,8,9,0,"!","@","#","$","%"}
		local Sentence = ""
		
		for i = 1,24 do
			local UpperOrNot = Random.new():NextInteger(1,2)
			if UpperOrNot == 1 then
				Sentence = Sentence.. string.upper(tostring(Words[Random.new():NextInteger(1,#Words)]))
			elseif UpperOrNot then
				Sentence = Sentence.. string.lower(tostring(Words[Random.new():NextInteger(1,#Words)]))
			end
		end
		
		Nametag.ImageLabel.TextLabel.Text = Sentence
		wait(0.05)
		Nametag.ImageLabel.TextLabel.Text = "Nectula, The Corrupted Demon"
	end
end)()

while true do
	Refit()
	Swait()
	Nametag.ImageLabel.Rotation = 3 * SIN(SINE / 0.5)
	Humanoid.HipHeight = 2
	SINE = SINE + 1 / 3
	--[[
	local TORSOVELOCITY = (Body.RootPart.Velocity * VT(1, 0, 1)).Magnitude
	local TORSOVERTICALVELOCITY = Body.RootPart.Velocity.Y
	local HITFLOOR = Raycast(Body.RootPart.Position, (CF(Body.RootPart.Position, Body.RootPart.Position + VT(0, -15, 0))).LookVector, 4, Character)
	local WALKSPEEDVALUE = 8 / (Humanoid.WalkSpeed / 16)
	
	if TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walking"
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
	end
	
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
	end
	]]
	for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
		v:Stop()
	end
	
	if Humanoid.MoveDirection.Magnitude == 0 then
		ANIM = "Idle"
	else
		ANIM = "Walking"
	end
	
	RightWingWeld.C0 = Clerp(RightWingWeld.C0, CF(-0.5,-0.2,-0.5) * ANGLES(RAD(0),RAD(15 * SIN(SINE / 5)),RAD(0)),0.4 / 3)
	LeftWingWeld.C0 = Clerp(LeftWingWeld.C0, CF(0.5,-0.2,-0.5) * ANGLES(RAD(0),RAD(-15 * SIN(SINE / 5)),RAD(0)),0.4 / 3)
	
	Horn2Weld.C0 = Clerp(Horn2Weld.C0,CF(-1,1.3 + 0.05 * SIN(SINE / 8),0) * ANGLES(RAD(5 * COS(SINE / 12)),RAD(0),RAD(-20) + 0.1 * COS(SINE / 7)),0.4 / 3)
	
	if ATTACK == false then
		local HIT,HITPOS = CastProperRay(Body.RootPart.CFrame.Position, (Body.RootPart.CFrame * CF(0,-100,0)).Position, 9999, Character)
		Effect({EffectType = "Round Slash";CFrame = CF(HITPOS) * ANGLES(RAD(RANDOM(-15,15)),RAD(RANDOM(-360,360)),RAD(RANDOM(-15,15)));Size = VT(0,0,0);Size2 = VT(0.1,0.01,0.1);Time = 0.2;Color = C3(1,0,1/100)})
		Effect({EffectType = "Wave";Trans = 0.7;CFrame = CF(HITPOS) * ANGLES(0,RAD(RANDOM(-360,360)),0);Size = VT(0,0,0);Size2 = VT(15,0.1,15);Time = 0.2;Color = C3(1,0,1/100)})
		if ANIM == "Idle" then
			PlayAnim(0.4 / 3, 1, {
				CF(0, -0.500000954, 0, -0.939692616, 0, -0.342020154, -0.342020154, 0, 0.939692616, 0, 1, 0) * ANGLES(RAD(5 * SIN(SINE / 12)),RAD(0),RAD(0));
				CF(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0) * CF(0,0,0 + 0.1 * COS(SINE / 7));
				CF(-0.5, 0.5, 0, 0, 0.173648179, 0.98480773, 0, 0.98480773, -0.173648179, -1, 0, 0) * ANGLES(RAD(5 * COS(SINE / 9)),RAD(0),RAD(0));
				CF(0.5, 0.499999762, 0, 0, -0.173648179, -0.98480773, 0, 0.98480773, -0.173648179, 1, 0, 0) * ANGLES(RAD(5 * COS(SINE / 9)),RAD(0),RAD(0));
				CF(0.5, 0.437385559, 0.0985031128, 0, 0, 1, 0.342019975, 0.939692676, 0, -0.939692676, 0.342019975, 0) * CF(0,0 - 0.2 * COS(SINE / 7),0) * ANGLES(RAD(10 - 9 * SIN(SINE / 7)),RAD(0),RAD(0));
				CF(-0.5, 0.879887581, 0.0889434814, 0, 0, -1, -0.258819044, 0.965925813, 0, 0.965925813, 0.258819044, 0) * CF(0,0 - 0.2 * COS(SINE / 7),0) * ANGLES(RAD(5 - 4 * SIN(SINE / 7)),RAD(0),RAD(0));
			})
		elseif ANIM == "Walking" then
			PlayAnim(0.4 / 3, 1, {
				CF(0, -0.5, 0, -0.965925872, -0.0885212719, -0.24321036, -0.258818984, 0.330365777, 0.90767312, 3.7252903e-09, 0.939692438, -0.342019826);
				CF(0, 0, 0, -1, 0, 0, 0, -0.342019945, 0.939692676, 0, 0.939692676, 0.342019945) * CF(0,0,0 + 0.1 * COS(SINE / 7));
				CF(-0.5, 0.5, 3.81469727e-06, 0, 0, 1, 0.766044378, 0.642787337, 0, -0.642787337, 0.766044378, 0) * ANGLES(RAD(5 * COS(SINE / 9)),RAD(0),RAD(0));
				CF(0.5, 0.5, 2.86102295e-06, 0, 0, -1, -0.866025269, 0.499999762, 0, 0.499999762, 0.866025269, 0) * ANGLES(RAD(5 * COS(SINE / 9)),RAD(0),RAD(0));
				CF(0.5, 1, 5.7220459e-06, 0, 0, 1, 0.57357651, 0.819151819, 0, -0.819151819, 0.57357651, 0) * ANGLES(RAD(10 * COS(SINE / 7)),RAD(0),RAD(0));
				CF(-0.5, 1, 3.81469727e-06, 0, 0, -1, -0.766044438, 0.642787457, 0, 0.642787457, 0.766044438, 0) * ANGLES(RAD(5 * COS(SINE / 7)),RAD(0),RAD(0));
			})
		end
	end
	
	local Desc = Character:GetDescendants()
	
	for i = 1,#Desc do
		local E = Desc[i]
		if E:IsA("Accessory") then
			table.insert(ToDelet,E)
		elseif E:IsA("Decal") and E.Name == "face" then
			table.insert(ToDelet,E)
		elseif E:IsA("SpecialMesh") and E.Parent == Body.Head then
			E.MeshType = "Head"
			E.Offset = VT(0,0.1,0)
		elseif E:IsA("Shirt") or E:IsA("ShirtGraphic") then
			table.insert(ToDelet,E)
		elseif E:IsA("ParticleEmitter") then
			if not E:IsDescendantOf(Effects) and not E:IsDescendantOf(script) then
				if E ~= Pt1 and E ~= Pt2 then
					table.insert(ToDelet,E)
				end
			end
		elseif E:IsA("BodyMover") and not E:IsDescendantOf(Effects) and E.Name ~= "MoveFat" then
			table.insert(ToDelet,E)
		end
	end
	
	for i = 1,#ToDelet do
		Ser.Debris:AddItem(ToDelet[i],0)
		table.remove(ToDelet,i)
	end
	
	for i = 1,#Invis do
		Invis[i].Transparency = 1
		table.remove(Invis,i)
	end
	
	Humanoid.MaxHealth = 99
	Humanoid.Health = 99
	Humanoid.Name = Random.new():NextNumber(-1000,1000)
end

