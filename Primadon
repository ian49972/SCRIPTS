local Players = game:GetService("Players")
local plr = Players.LocalPlayer

local model = game:GetObjects("rbxassetid://17523790773")[1]
local monkyContainer = model:FindFirstChild("MonkyContainer")
local mobChar = monkyContainer and monkyContainer:FindFirstChild("Main") and monkyContainer.Main:FindFirstChild("Monky")
if not mobChar then
    warn("Monky character not found")
    return
end

mobChar.Parent = workspace

local humanoid = mobChar:WaitForChild("Humanoid")
local hrp = mobChar:WaitForChild("HumanoidRootPart")

hrp.CFrame = plr.Character.HumanoidRootPart.CFrame + Vector3.new(0,40,0)

humanoid.MaxHealth = 999999999
humanoid.Health = 999999999
humanoid.WalkSpeed = 32
humanoid.JumpPower = 300
humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None

local oldChar = plr.Character
plr.Character = mobChar

local cam = workspace.CurrentCamera
cam.CameraSubject = humanoid
cam.CFrame = hrp.CFrame

if oldChar and oldChar ~= mobChar then
    oldChar:Destroy()
end

if monkyContainer then
    local mainModule = monkyContainer:FindFirstChild("MainModule")
    if mainModule then
        mainModule:Destroy()
    end
end
-- custom animation system (fixed C0)
-- by moon (edit by popbottoms), adapted for client usage

local animators = setmetatable({},{__mode = "k"})
local FPS = 60
local secsPerFrame = 1/FPS
local blankPoses = true -- Non used poses are there with default cf

local priorityOrder = {
	[Enum.AnimationPriority.Core] = 1,
	[Enum.AnimationPriority.Idle] = 2,
	[Enum.AnimationPriority.Movement] = 3,
	[Enum.AnimationPriority.Action] = 4,
	[Enum.AnimationPriority.Action2] = 5,
	[Enum.AnimationPriority.Action3] = 6,
	[Enum.AnimationPriority.Action4] = 7,
}

-- Artificial Heartbeat --
local ArtificialHB = Instance.new("BindableEvent")
ArtificialHB.Name = "Heartbeat"

local tf = 0
local allowframeloss = false
local tossremainder = false
local frame = 1/FPS
local maxFrameFix = 10
ArtificialHB:Fire()
local doquick = false

game:GetService("RunService").Heartbeat:Connect(function(s, p)
	tf += s
	if tf >= frame then
		local maxFrames = math.min(maxFrameFix, math.floor(tf / frame))
		if allowframeloss then
			ArtificialHB:Fire()
		else
			for i = 1, maxFrames do
				ArtificialHB:Fire()
			end
		end
		if tossremainder then
			tf = 0
		else
			tf -= frame * maxFrames
		end
	end
end)

local function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:Wait()
	else
		for _ = 1, num do
			ArtificialHB.Event:Wait()
		end
	end
end
-- End of Artificial Heartbeat --

local function cfSort(t1,t2)
	if t1[3] == t2[3] then
		return t1[4] < t2[4]
	else
		return t1[3] < t2[3]
	end
end

local function processAnimators()
	local toProcess = {}
	for animator in animators do table.insert(toProcess,animator) end

	local motorCFTable = {}

	for _,animator in ipairs(toProcess) do
		local motors = animator.Motors
		local tracksClone = table.clone(animator.Tracks)

		for _,track in pairs(tracksClone) do
			local weight = track.Weight
			if weight == 0 then continue end
			track.StepTime += secsPerFrame*track.Speed

			for _,keyframe in pairs(track.Keyframes) do
				if keyframe.Time > track.LastStepTime and keyframe.Time <= track.StepTime then
					track.KeyframeReached:Fire(keyframe.Name)
				end
			end

			if track.StepTime > track.Length then
				if track.Loop then
					track.LastStepTime = 0
					track.StepTime = track.StepTime % track.Length
					track.KeyframeReached:Fire(track.Keyframes[1].Name)
				elseif not track.StopFlag then
					track:Stop(0.3)
				end
			end

local gotMotors = {}
			for motorName,poses in pairs(track.Poses) do
				local workPose = poses[1]
				local workPoseIndex = 1

				for i = 2,#poses do
					local pose = poses[i]
					if track.StepTime >= pose[1] then
						workPose = pose
						workPoseIndex = i
					else
						break
					end
				end

				local poseTime,poseInst = workPose[1],workPose[2]

				local motor = motors[motorName]
				local c00 = motor.c
				local originalmotor = motor
				motor = motor.m
				if not motor then continue end

				local poseCF = poseInst.CFrame
				local motorCFs = motorCFTable[originalmotor]
				if not motorCFs then
					motorCFs = {}
					motorCFTable[originalmotor] = motorCFs
				end

				local lerpedCF
				local nextPose = poses[workPoseIndex+1]
				if not nextPose then
					lerpedCF = poseCF
				else
					local delta = (track.StepTime - poseTime)/(nextPose[1] - poseTime)
					lerpedCF = poseCF:Lerp(nextPose[2].CFrame,delta)
				end

				table.insert(motorCFs,{weight,lerpedCF,priorityOrder[track.Priority],track.PlayTime})
				gotMotors[motor] = true
			end

			if blankPoses then
				for _,motor in motors do
					if gotMotors[motor.m] then continue end
					local motorCFs = motorCFTable[motor]
					if not motorCFs then
						motorCFs = {}
						motorCFTable[motor] = motorCFs
					end
					table.insert(motorCFs,{weight,CFrame.identity,priorityOrder[track.Priority],track.PlayTime})
				end
			end

			track.LastStepTime = track.StepTime
		end
	end

	for motor,cframes in pairs(motorCFTable) do
		table.sort(cframes,cfSort)
		local c00 = motor.c
		local motor6d = motor.m

		for _,cframe in ipairs(cframes) do
			local speed = math.clamp(cframe[1],0,1)
			if doquick then speed = 1 end
			motor6d.C0 = motor6d.C0:Lerp(c00 * cframe[2],speed)
		end
	end
	doquick = false
end

ArtificialHB.Event:Connect(processAnimators)

-- Classes
local classes = {}

classes.Signal = (function()
	local funcs = {}
	local disconnect = function(con)
		local pos = table.find(con.Signal.Connections,con)
		if pos then table.remove(con.Signal.Connections,pos) end
	end
	funcs.Connect = function(self,func)
		local con = {Signal=self,Func=func,Disconnect=disconnect}
		self.Connections[#self.Connections+1] = con
		return con
	end
	funcs.Fire = function(self,...)
		for _,v in next,self.Connections do
			task.spawn(v.Func,...)
		end
	end
	local mt = {__index = funcs}
	local function new()
		local self = {Connections={}}
		return setmetatable(self,mt)
	end
	return {new = new}
end)()

classes.Track = (function()
	local funcs = {}
	local mt = {__index = funcs}

	local function initPoses(self)
		local poses = self.Poses
		for _,v in pairs(self.KeyframeSequence:GetChildren()) do
			local keyTime = v.Time
			for _,pose in pairs(v:GetDescendants()) do
				if pose:IsA("Pose") and pose.Weight > 0 then
					local poseTable = poses[pose.Name]
					if not poseTable then
						poseTable = {}
						poses[pose.Name] = poseTable
					end
					table.insert(poseTable,{keyTime,pose})
				end
			end
			if keyTime > self.Length then
				self.Length = keyTime
			end
			table.insert(self.Keyframes,v)
		end
		for _,v in pairs(poses) do
			table.sort(v,function(a,b) return a[1] < b[1] end)
		end
	end

local function fadeWeight(self,target,secs)
		local startTime = tick()
		local endTime = startTime+secs
		local startWeight = self.Weight
		self.LastFade = startTime
		task.spawn(function()
			while true do
				if self.LastFade ~= startTime then return end
				local curTime = tick()
				if curTime >= endTime then break end
				local frac = (curTime - startTime)/(endTime - startTime)
				self.Weight = startWeight + (target - startWeight)*frac
				task.wait()
			end
			self.Weight = target
			if target == 0 then
				local foundInd = table.find(self.Animator.Tracks,self)
				if foundInd then
					table.remove(self.Animator.Tracks,foundInd)
				end
			end
		end)
	end

	funcs.Play = function(self,fadeTime,weight,speed)
		self.Speed = speed or 1
		self.PlayTime = tick()
		if not self.Loop or self.Weight == 0 then
			self.LastStepTime = 0
			self.StepTime = 0
		end
		self.StopFlag = false
		self.IsPlaying = true
		fadeWeight(self,weight or 1,fadeTime or 0.1)
		doquick = true
		if not table.find(self.Animator.Tracks,self) then
			table.insert(self.Animator.Tracks,self)
		end
	end

	funcs.Stop = function(self,fadeTime)
		self.StopFlag = true
		self.IsPlaying = false
		fadeWeight(self,0,fadeTime or 0.1)
		self.Stopped:Fire()
	end

	local function new(animator,keyframeSeq)
		local self = setmetatable({
			Poses = {},
			Keyframes = {},
			Speed = 1,
			Weight = 0,
			LastStepTime = 0,
			StepTime = 0,
			Length = 0,
			Loop = keyframeSeq.Loop,
			LastFade = 0,
			PlayTime = 0,
			Priority = keyframeSeq.Priority,
			KeyframeReached = classes.Signal.new(),
			KeyframeSequence = keyframeSeq,
			Animator = animator,
			IsPlaying = false,
			Stopped = classes.Signal.new()
		},mt)
		initPoses(self)
		return self
	end

	return {new = new}
end)()

classes.Animator = (function()
	local funcs = {}
	local mt = {__index = funcs}

	funcs.InitMotors = function(self)
		for _,v in pairs(self.Model:GetDescendants()) do
			if v:IsA("Motor6D") then
				self.Motors[v.Part1.Name] = {m=v,c=v.C0}
			elseif v:IsA("Bone") then
				self.Motors[v.Name] = {m=v,c=CFrame.new()}
			end
		end
	end

funcs.LoadAnimation = function(self,keyframeSeq)
		local newTrack = classes.Track.new(self,keyframeSeq)
		return newTrack
	end

	local function new(model)
		local self = setmetatable({
			Tracks = {},
			Motors = {},
			Model = model
		},mt)
		self:InitMotors()
		animators[self] = true
		return self
	end

	return {new = new}
end)()

local function createAnimator(model)
	return classes.Animator.new(model)
end

-- ===============================
-- USAGE WITH HUMANOID ANIMS
-- ===============================

local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")

local mobChar = char
local animsFolder = mobChar:WaitForChild("Anims")

local animator = createAnimator(mobChar)

local currentTrack

local function playKeyframeSequence(seq)
	if currentTrack then
		currentTrack:Stop(0.2)
	end
	local track = animator:LoadAnimation(seq)
	track:Play(0.2,1,1)
	currentTrack = track
	return track
end

local function updateAnimation()
	if humanoid.MoveDirection.Magnitude > 0 then
		playKeyframeSequence(animsFolder:WaitForChild("Walk"))
	elseif humanoid:GetState() == Enum.HumanoidStateType.Jumping or humanoid:GetState() == Enum.HumanoidStateType.Freefall then
		playKeyframeSequence(animsFolder:WaitForChild("Jump"))
	else
		playKeyframeSequence(animsFolder:WaitForChild("Idle"))
	end
end

humanoid.Running:Connect(updateAnimation)
humanoid.StateChanged:Connect(updateAnimation)
updateAnimation()


-- Gui
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local ControllerGui = Instance.new("ScreenGui")
ControllerGui.Name = "ControllerGui"
ControllerGui.Parent = player:WaitForChild("PlayerGui")

local TextBoxTemplate = Instance.new("Frame")
TextBoxTemplate.Name = "TextBoxTemplate"
TextBoxTemplate.Parent = ControllerGui
TextBoxTemplate.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextBoxTemplate.BackgroundTransparency = 1
TextBoxTemplate.BorderColor3 = Color3.fromRGB(27, 42, 53)
TextBoxTemplate.BorderSizePixel = 1
TextBoxTemplate.Position = UDim2.new(0, 0, 0, 0)
TextBoxTemplate.Size = UDim2.new(1, 0, 0, 50)
TextBoxTemplate.AnchorPoint = Vector2.new(0, 0)
TextBoxTemplate.Visible = false
TextBoxTemplate.ZIndex = 1
TextBoxTemplate.ClipsDescendants = false
TextBoxTemplate.LayoutOrder = 0
TextBoxTemplate.Active = false

local Box = Instance.new("TextBox")
Box.Name = "Box"
Box.Parent = TextBoxTemplate
Box.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Box.BackgroundTransparency = 0
Box.BorderColor3 = Color3.fromRGB(30, 30, 30)
Box.BorderSizePixel = 0
Box.Position = UDim2.new(0, 5, 0, 20)
Box.Size = UDim2.new(1, -10, 0, 25)
Box.Font = Enum.Font.SourceSans
Box.Text = ""
Box.TextColor3 = Color3.fromRGB(255, 255, 255)
Box.TextSize = 14
Box.TextScaled = false
Box.TextWrapped = false
Box.TextTransparency = 0
Box.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
Box.TextStrokeTransparency = 1
Box.AnchorPoint = Vector2.new(0, 0)
Box.Visible = true
Box.ZIndex = 1
Box.ClipsDescendants = false
Box.LayoutOrder = 0
Box.ClearTextOnFocus = true
Box.PlaceholderText = ""
Box.PlaceholderColor3 = Color3.fromRGB(200, 200, 200)
Box.MultiLine = false
Box.Active = true
Box.LineHeight = 1
Box.CursorPosition = 1
Box.TextEditable = true
Box.MaxVisibleGraphemes = -1

local UICorner = Instance.new("UICorner")
UICorner.Name = "UICorner"
UICorner.Parent = Box

local TextLabel = Instance.new("TextLabel")
TextLabel.Name = "TextLabel"
TextLabel.Parent = TextBoxTemplate
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1
TextLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
TextLabel.BorderSizePixel = 1
TextLabel.Position = UDim2.new(0, 5, 0, 0)
TextLabel.Size = UDim2.new(1, -10, 0, 20)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "Speed"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextSize = 14
TextLabel.TextScaled = false
TextLabel.TextWrapped = false
TextLabel.TextTransparency = 0
TextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextStrokeTransparency = 1
TextLabel.AnchorPoint = Vector2.new(0, 0)
TextLabel.Visible = true
TextLabel.ZIndex = 1
TextLabel.ClipsDescendants = false
TextLabel.LayoutOrder = 0
TextLabel.Active = false
TextLabel.LineHeight = 1
TextLabel.MaxVisibleGraphemes = -1

local Frame = Instance.new("Frame")
Frame.Name = "Frame"
Frame.Parent = ControllerGui
Frame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
Frame.BackgroundTransparency = 0
Frame.BorderColor3 = Color3.fromRGB(27, 42, 53)
Frame.BorderSizePixel = 0
Frame.Position = UDim2.new(0.05000000074505806, 0, 0.6000000238418579, 0)
Frame.Size = UDim2.new(0, 150, 0, 165)
Frame.AnchorPoint = Vector2.new(0, 0)
Frame.Visible = true
Frame.ZIndex = 1
Frame.ClipsDescendants = false
Frame.LayoutOrder = 0
Frame.Active = true

local UICorner = Instance.new("UICorner")
UICorner.Name = "UICorner"
UICorner.Parent = Frame

local Title = Instance.new("TextLabel")
Title.Name = "Title"
Title.Parent = Frame
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1
Title.BorderColor3 = Color3.fromRGB(27, 42, 53)
Title.BorderSizePixel = 1
Title.Position = UDim2.new(0, 5, 0, 0)
Title.Size = UDim2.new(1, -10, 0, 25)
Title.Font = Enum.Font.SourceSansBold
Title.Text = "Grandosla"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 14
Title.TextScaled = false
Title.TextWrapped = false
Title.TextTransparency = 0
Title.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
Title.TextStrokeTransparency = 1
Title.AnchorPoint = Vector2.new(0, 0)
Title.Visible = true
Title.ZIndex = 1
Title.ClipsDescendants = false
Title.LayoutOrder = 0
Title.Active = false
Title.LineHeight = 1
Title.MaxVisibleGraphemes = -1

local ButtonTemplate = Instance.new("TextButton")
ButtonTemplate.Name = "ButtonTemplate"
ButtonTemplate.Parent = ControllerGui
ButtonTemplate.BackgroundColor3 = Color3.fromRGB(0, 135, 203)
ButtonTemplate.BackgroundTransparency = 0
ButtonTemplate.BorderColor3 = Color3.fromRGB(27, 42, 53)
ButtonTemplate.BorderSizePixel = 1
ButtonTemplate.Position = UDim2.new(0, 5, 1, -140)
ButtonTemplate.Size = UDim2.new(1, -10, 0, 25)
ButtonTemplate.Font = Enum.Font.SourceSans
ButtonTemplate.Text = "Power On/Off"
ButtonTemplate.TextColor3 = Color3.fromRGB(255, 255, 255)
ButtonTemplate.TextSize = 14
ButtonTemplate.TextScaled = false
ButtonTemplate.TextWrapped = false
ButtonTemplate.TextTransparency = 0
ButtonTemplate.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
ButtonTemplate.TextStrokeTransparency = 1
ButtonTemplate.AnchorPoint = Vector2.new(0, 0)
ButtonTemplate.Visible = false
ButtonTemplate.ZIndex = 1
ButtonTemplate.ClipsDescendants = false
ButtonTemplate.LayoutOrder = 0
ButtonTemplate.Active = true
ButtonTemplate.LineHeight = 1
ButtonTemplate.MaxVisibleGraphemes = -1

local UICorner = Instance.new("UICorner")
UICorner.Name = "UICorner"
UICorner.Parent = ButtonTemplate
 
local plr = game:GetService("Players").LocalPlayer
local mouse = plr:GetMouse()
local char = plr.Character
 
local UIS = game:GetService("UserInputService")
 
-- Gui Lib --
local gui = player:WaitForChild("PlayerGui"):WaitForChild("ControllerGui")
local frame = gui:WaitForChild("Frame")
 
local initSize = 25
local buttonSize = 30
local textBoxSize = 50
local baseWidth = 150
local buttonTemplate = gui:WaitForChild("ButtonTemplate")
local textBoxTemplate = gui:WaitForChild("TextBoxTemplate")
local nextPosition = initSize
 
local function setTitle(text)
    frame:WaitForChild("Title").Text = text
end
 
local function newButton(text,clickFunc)
    local newButtonGui = buttonTemplate:Clone()
    newButtonGui.Position = UDim2.new(0,5,0,nextPosition)
    nextPosition = nextPosition + buttonSize
    
    newButtonGui.Text = text
    newButtonGui.Visible = true
    
    if clickFunc then
        newButtonGui.MouseButton1Click:Connect(clickFunc)
    end
    
    frame.Size = UDim2.new(0,150,0,nextPosition)
    newButtonGui.Parent = frame
    
    return newButtonGui
end
 
local function newTextBox(label,defaultText,changedFunc)
    local newFrame = textBoxTemplate:Clone()
    newFrame.Position = UDim2.new(0,0,0,nextPosition)
    nextPosition = nextPosition + textBoxSize
    
    newFrame.TextLabel.Text = label
    newFrame.Box.Text = defaultText or ""
    newFrame.Visible = true
    
    if changedFunc then
        newFrame.Box.FocusLost:Connect(function()
            changedFunc(newFrame.Box.Text)
        end)
    end
    
    frame.Size = UDim2.new(0,150,0,nextPosition)
    newFrame.Parent = frame
    
    return newFrame
end
 
local mouse = game:GetService("Players").LocalPlayer:GetMouse()
frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        local releaseEvent,mouseEvent
        
        local initX = frame.AbsolutePosition.X
        local initY = frame.AbsolutePosition.Y
        local offX = mouse.X - initX
        local offY = mouse.Y - initY
        
        releaseEvent = UIS.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                releaseEvent:Disconnect()
                mouseEvent:Disconnect()
            end
        end)

mouseEvent = UIS.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement then
                local inputX,inputY = input.Position.X,input.Position.Y
                local posX,posY = inputX-offX,inputY-offY
                frame.Position = UDim2.new(0,posX,0,posY)
            end
        end)
    end
end)
 
----------------------------------------------
 
local sets = {
DestroyParts = true,
DestroyAnchored = false,
MaxMass = 0,
SplitParts = true,
DestructiveWalk = false,
}
 
local anchoredButton,anchoredBox,splitButton,walkButton,partsButton
local function updateButtons()
    anchoredButton.Text = "Destroyed Anchored: "..tostring(sets.DestroyAnchored)
    anchoredBox.Box.Text = tostring(sets.MaxMass)
    splitButton.Text = "Split Parts: "..tostring(sets.SplitParts)
    walkButton.Text = "Destructive Walk: "..tostring(sets.DestructiveWalk)
    partsButton.Text = "Destroy Parts: "..tostring(sets.DestroyParts)
end
 
setTitle("Monky")
 
cleanButton = newButton("Clean Parts",function()
    print(" ")
end)
 
partsButton = newButton("Destroy Parts",function()
    sets.DestroyParts = not sets.DestroyParts
    partsButton.Text = "Destroy Parts: "..tostring(sets.DestroyParts)
end)
 
splitButton = newButton("Split Parts",function()
    sets.SplitParts = not sets.SplitParts
    splitButton.Text = "Split Parts: "..tostring(sets.SplitParts)
end)
 
walkButton = newButton("Destructive Walk",function()
    sets.DestructiveWalk = not sets.DestructiveWalk
    walkButton.Text = "Destructive Walk: "..tostring(sets.DestructiveWalk)
end)
 
anchoredButton = newButton("Destroyed Anchored",function()
    sets.DestroyAnchored = not sets.DestroyAnchored
    anchoredButton.Text = "Destroyed Anchored: "..tostring(sets.DestroyAnchored)
end)
 
anchoredBox = newTextBox("Max Anchored Mass","",function()
    sets.MaxMass = tonumber(anchoredBox.Box.Text) or 0
    anchoredBox.Box.Text = tostring(sets.MaxMass)
end)
 
updateButtons()
 
 
 
local h,t
local normalMap = {}
 
for i,v in pairs(Enum.NormalId:GetEnumItems()) do
    local vec = Vector3.FromNormalId(v)
    normalMap[vec] = v
end
 
local function isFiltered(obj)
    return not obj.CanCollide
end
 
while task.wait(1/60) do
    local Mouse = mouse
    local Target,Hit
    local TargetSurface = Enum.NormalId.Right
    
    local filterList = {plr.Character}
    
    while true do
        local params = RaycastParams.new()
        params.FilterType = Enum.RaycastFilterType.Blacklist
        params.FilterDescendantsInstances = filterList
        
        local res = workspace:Raycast(Mouse.Origin.Position,Mouse.Origin.LookVector*100000,params)
        if res then
            local objectNormal = res.Instance.CFrame:ToObjectSpace(res.Instance.CFrame + res.Normal).p
            objectNormal = Vector3.new(math.round(objectNormal.X), math.round(objectNormal.Y), math.round(objectNormal.Z))
            
            local inst = res.Instance
            if isFiltered(inst) then
                table.insert(filterList,inst)
                continue
            else
                Target = inst
                
                if objectNormal.Magnitude > 1 then
                    objectNormal = objectNormal * Vector3.new(0,1,1)
                    if objectNormal.Magnitude > 1 then
                        objectNormal = objectNormal * Vector3.new(0,0,1)
                    end
                end
                
                TargetSurface = normalMap[objectNormal]
                Hit = CFrame.new(res.Position,res.Position + Mouse.Origin.LookVector)
                break
            end
        else
            break
        end
    end
    
    Hit = Hit or Mouse.Hit
    
    if h~=Hit or t~=Target then
        event:Fire("MousePos",Hit,Target)
        h,t=Hit,Target
    end
end
