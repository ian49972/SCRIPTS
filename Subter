writefile("SUBTER.mp3", game:HttpGet("https://github.com/ian49972/smth/raw/refs/heads/main/SUBTER.mp3"))

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local player = Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local backpack = player:WaitForChild("Backpack")

local tool = Instance.new("Tool")
tool.Name = "subterfuge"
tool.RequiresHandle = false
tool.Parent = backpack

local currentAnim = nil
local animationActive = false
local cleanupRunning = false
local soundInstance = nil
local originalSpeed = nil

local tStyle, tDirection = {
	[Enum.PoseEasingStyle.Linear] = Enum.EasingStyle.Linear,
	[Enum.PoseEasingStyle.Bounce] = Enum.EasingStyle.Bounce,
	[Enum.PoseEasingStyle.Cubic] = Enum.EasingStyle.Cubic,
	[Enum.PoseEasingStyle.Elastic] = Enum.EasingStyle.Elastic,
	[Enum.PoseEasingStyle.Constant] = Enum.EasingStyle.Linear,
}, {
	[Enum.PoseEasingDirection.In] = Enum.EasingDirection.In,
	[Enum.PoseEasingDirection.Out] = Enum.EasingDirection.Out,
	[Enum.PoseEasingDirection.InOut] = Enum.EasingDirection.InOut,
}

local function PlayKeyframeSequence(Model, KeyFrameSequence, SpeedMult)
	SpeedMult = SpeedMult or 1
	local AllKeyFrames = {}
	for _, Keyframe in pairs(KeyFrameSequence:GetKeyframes()) do
		table.insert(AllKeyFrames, { Time = Keyframe.Time, Keyframe = Keyframe })
	end
	table.sort(AllKeyFrames, function(a, b) return a.Time < b.Time end)

	local tweens, motors, motorValues, KeyFramePoses = {}, {}, {}, {}

	local function GetMotorFromPose(Pose)
		for _, v in pairs(Model:GetDescendants()) do
			if v:IsA("Motor6D") and v.Part1 and v.Part1.Name == Pose.Name and v.Part0 and v.Part0.Name == Pose.Parent.Name then
				return v
			end
		end
		return nil
	end

	for i, Keyframe in ipairs(AllKeyFrames) do
		KeyFramePoses[i] = { Time = Keyframe.Time, Poses = {} }
		for _, Pose in pairs(Keyframe.Keyframe:GetDescendants()) do
			if Pose:IsA("Pose") and Pose.Weight > 0 then
				local Motor6D = motors[Pose.Name] or GetMotorFromPose(Pose)
				if Motor6D then
					motors[Pose.Name] = Motor6D
					if not motorValues[Pose.Name] then
						local motorVal = Instance.new("CFrameValue")
						motorVal.Name = "MotorValue"
						motorVal.Parent = Motor6D
						motorValues[Pose.Name] = motorVal
					end
					KeyFramePoses[i].Poses[Pose.Name] = { Motor6D = Motor6D, Pose = Pose }
				end
			end
		end
	end

	if #KeyFramePoses > 1 then
		local lastPose = {}
		for i = 1, #KeyFramePoses - 1 do
			local KF1, KF2 = KeyFramePoses[i], KeyFramePoses[i + 1]
			local duration = (KF2.Time - KF1.Time) / SpeedMult
			tweens[i] = { Time = duration, Tweens = {} }
			for name, data in pairs(KF1.Poses) do lastPose[name] = data end
			for name, data in pairs(KF2.Poses) do
				if lastPose[name] then
					local tweenInfo = TweenInfo.new(
						duration,
						tStyle[data.Pose.EasingStyle] or Enum.EasingStyle.Linear,
						tDirection[data.Pose.EasingDirection] or Enum.EasingDirection.InOut
					)
					tweens[i].Tweens[name] = TweenService:Create(motorValues[name], tweenInfo, { Value = data.Pose.CFrame })
				end
			end
		end
	end

	local connection
	connection = RunService.Heartbeat:Connect(function()
		for name, motor in pairs(motors) do
			if motorValues[name] and motorValues[name].Value then
				motor.Transform = motorValues[name].Value
			end
		end
	end)

	local running = true
	local function getLength()
		return (KeyFramePoses[#KeyFramePoses].Time / SpeedMult) + 10
	end

	local function play()
		for i, tweenData in ipairs(tweens) do
			for _, tween in pairs(tweenData.Tweens) do tween:Play() end
			task.wait(tweenData.Time)
			if not running then break end
		end
	end

	spawn(function()
		play()
		running = false
		if connection and connection.Connected then connection:Disconnect() end
		for _, tweenData in pairs(tweens) do
			for _, tween in pairs(tweenData.Tweens) do
				pcall(function() tween:Cancel() end)
			end
		end
	end)

	local function stop()
		if not running then return end
		running = false
		if connection and connection.Connected then connection:Disconnect() end
		for _, tweenData in pairs(tweens) do
			for _, tween in pairs(tweenData.Tweens) do
				pcall(function() tween:Cancel() end)
			end
		end
	end

	return {
		getLength = getLength,
		stop = stop,
		isRunning = function() return running end
	}
end

local function attachFinger(handle, arm, jointName, offset)
	local basePart = handle:FindFirstChildWhichIsA("BasePart")
	if not basePart then return nil end
	for _, part in handle:GetDescendants() do
		if part:IsA("BasePart") then
			part.Anchored = false
			part.BrickColor = arm.BrickColor
		end
	end
	handle.Parent = char
	handle:PivotTo(arm.CFrame * offset)
	local motor = Instance.new("Motor6D")
	motor.Name = jointName
	motor.Part0 = arm
	motor.Part1 = basePart
	motor.C0 = arm.CFrame:ToObjectSpace(basePart.CFrame)
	motor.C1 = CFrame.new()
	motor.Parent = arm
	return motor
end

local leftHandle, rightHandle
local leftMotor, rightMotor

local function removeFingers()
	if leftMotor and leftMotor.Parent then leftMotor:Destroy() end
	if rightMotor and rightMotor.Parent then rightMotor:Destroy() end
	if leftHandle and leftHandle.Parent then leftHandle:Destroy() end
	if rightHandle and rightHandle.Parent then rightHandle:Destroy() end
	leftMotor, rightMotor, leftHandle, rightHandle = nil, nil, nil, nil
end

local function spawnFingers(assetId)
	local ok, model = pcall(function() return game:GetObjects(assetId)[1] end)
	if not ok or not model then return end
	leftHandle = model:FindFirstChild("LeftHandle")
	rightHandle = model:FindFirstChild("RightHandle")
	if not (leftHandle and rightHandle) then
		if model and model.Parent then model:Destroy() end
		return
	end
	local leftArm = char:FindFirstChild("Left Arm") or char:FindFirstChild("LeftUpperArm") or char:WaitForChild("Left Arm")
	local rightArm = char:FindFirstChild("Right Arm") or char:FindFirstChild("RightUpperArm") or char:WaitForChild("Right Arm")
	local handOffset = CFrame.new(0, -0.88, 0)
	leftMotor = attachFinger(leftHandle, leftArm, "LeftFingerJoint", handOffset)
	rightMotor = attachFinger(rightHandle, rightArm, "RightFingerJoint", handOffset)
	model:Destroy()
end

local function cleanup()
	if cleanupRunning then return end
	cleanupRunning = true

	if currentAnim then
		pcall(function() currentAnim.stop() end)
		currentAnim = nil
	end

	removeFingers()

	if soundInstance then
		pcall(function()
			if soundInstance.IsPlaying then soundInstance:Stop() end
			soundInstance:Destroy()
		end)
		soundInstance = nil
	end

	local hum = char:FindFirstChildOfClass("Humanoid")
	if hum and originalSpeed then
		pcall(function() hum.WalkSpeed = originalSpeed end)
		originalSpeed = nil
	end

	local humObj = char:FindFirstChildOfClass("Humanoid")
	if humObj then
		local existingAnimator = humObj:FindFirstChildOfClass("Animator")
		if not existingAnimator then
			local newAnimator = Instance.new("Animator")
			newAnimator.Parent = humObj
		end
	end

	animationActive = false
	tool.Name = "subterfuge"
	cleanupRunning = false
end

tool.Activated:Connect(function()
	if animationActive then
		cleanup()
		return
	end

	animationActive = true
	tool.Name = "Stop"
	originalSpeed = nil

	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then
		animationActive = false
		tool.Name = "subterfuge"
		return
	end

	originalSpeed = hum.WalkSpeed

	local assetId = "rbxassetid://18637374258"
	local subModelSafeAsset = "rbxassetid://82703883871076"

	local subModel
	do
		local ok, m = pcall(function() return game:GetObjects(subModelSafeAsset)[1] end)
		if ok then subModel = m end
	end
	if subModel then
		subModel.Parent = workspace
		local subKeyframe = subModel:FindFirstChild("sub")
		if subKeyframe then
			subKeyframe.Parent = ReplicatedStorage
		end
		if subModel and subModel.Parent then
			subModel:Destroy()
		end
	end

	local animator = hum:FindFirstChildOfClass("Animator")
	if animator then animator:Destroy() end

	spawnFingers(assetId)

	soundInstance = Instance.new("Sound")
	soundInstance.SoundId = getcustomasset("SUBTER.mp3")
	soundInstance.Volume = 1
	soundInstance.Looped = false
	soundInstance.Parent = workspace
	pcall(function() soundInstance:Play() end)

	local keyframe = ReplicatedStorage:FindFirstChild("sub")
	if not keyframe then
		cleanup()
		return
	end

	currentAnim = PlayKeyframeSequence(workspace.ban_thid, keyframe, 1.6)

	hum.WalkSpeed = 0

	spawn(function()
		local length = 0
		local ok, l = pcall(function() return currentAnim and currentAnim.getLength() or 0 end)
		if ok then length = l end
		local elapsed = 0
		local interval = 0.1
		while elapsed < length do
			if not animationActive then break end
			task.wait(interval)
			elapsed = elapsed + interval
		end
		if animationActive then
			cleanup()
		end
	end)
end)
