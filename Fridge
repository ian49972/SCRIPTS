game:GetService("StarterGui"):SetCore("SendNotification", { 
	Title = "ban_notification";
	Text = "This script is converted by ban_thid";
	Icon = "rbxthumb://type=Asset&id=71967665601624&w=150&h=150"})
Duration = 15;

local Object = game:GetObjects("rbxassetid://5813737611")[1]  
Object.Parent = game.Workspace  
script = Object.Fridge

	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
-- converter by Drahazar

--created by helkern
--some things might be taken from other scripts

wait(1/60)

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local neck2 = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
--ROBLOXIDLEANIMATION.Parent = Humanoid
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
ANIMATOR:Destroy()
local UNANCHOR = true
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}	
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function Clerp(a, b, t)
    return a:lerp(b,t)
end



function weld(parent, part0, part1, c0, c1)
	local w = IT("Weld")
	w.Part0 = part0
	w.Part1 = part1
	w.C0 = c0
	w.C1 = c1
	w.Parent = parent
	return w
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLORLOOP = (Table.ColorLoop or false)
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
					EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
						EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end


function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						local CAMSHAKER = script.CamShake:Clone()
						CAMSHAKER.Shake.Value = INTENSITY
						CAMSHAKER.Timer.Value = TIME
						CAMSHAKER.Parent = CHILD
						CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end


function AttachmentCFrame(What)
	return What.Parent.CFrame*CF(What.Position)
end


--weap
local SONG = 4389772331
d = CF(0,0,0)
local la = IT("Weld")
local ra = IT("Weld")
RightShoulder.Parent = nil
LeftShoulder.Parent = nil
ra.Name = "ra"
ra.Part0 = Torso 
ra.C0 = CF(1.5, 0.5, 0)
ra.C1 = CF(0, 0.5, 0)
ra.Part1 = RightArm
ra.Parent = Torso  

la.Name = "la"
la.Part0 = Torso 
la.C0 = CF(-1.5, 0.5, 0)
la.C1 = CF(0, 0.5, 0) 
la.Part1 = LeftArm
la.Parent = Torso

local lh = weld(LeftLeg,Torso,LeftLeg,CF(-.5,-1,0),d)
lh.C1 = CF(0,1,0)
local rh = weld(RightLeg,Torso,RightLeg,CF(.5,-1,0),d)
rh.C1 = CF(0,1,0)

local cm = script.THEFRIDGE
for i,v in pairs(cm:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Anchored = false
	end
end
local w2 = weld(LeftArm,cm.la,LeftArm,d,d)
local w3 = weld(LeftLeg,cm.ll,LeftLeg,d,d)
local w4 = weld(RightArm,cm.ra,RightArm,d,d)
local w5 = weld(RightLeg,cm.rl,RightLeg,d,d)
local w6 = weld(Torso,cm.tors,Torso,d,d)
Humanoid:removeAccessories()
for i,v in pairs(Character:GetChildren()) do
if v:IsA("Part") then
	v.Transparency = 1
end	
end
if Head.face then
	Head.face.Transparency = 1
end
RootJoint.C1 = RootJoint.C1*CF(0,0,-2)
	local milgk = script.bigmilk
	milgk.Parent = nil
	local lefthand = cm.la.hand
	local bottomw = cm.tors.mainfridge.bottomweld
	local topw = cm.tors.mainfridge.topweld
	
	local topopen = false
	local botopen = false
	
	local attackfridge = script.attackfridge
	local attacktimb = script.attacktimb
	attackfridge.Parent = nil
	attacktimb.Parent = nil
	
	local headpoint = cm.tors.insidetop.headpoint
	
	local hidden = false

--dmg
function ApplyDamage(Humanoid,Damage)
	Damage = Damage
	if Humanoid.Health < 2000 then
		if Humanoid.Health - Damage > 0 then
			Humanoid.Health = Humanoid.Health - Damage
		else
			Humanoid.Parent:BreakJoints()
		end
	else
		Humanoid.Parent:BreakJoints()
	end
end

function ApplyAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--attacks
function cs()
	if SONG == 4389772331 then
		SONG = 225561722
	elseif SONG == 225561722 then
		SONG = 1556083710
	elseif SONG == 1556083710 then
		SONG = 3983664157
	elseif SONG == 3983664157 then
		SONG = 1171041120
	elseif SONG == 1171041120 then
		SONG = 1259285896	
	elseif SONG == 1259285896 then
		SONG = 1059884825
	elseif SONG == 1059884825 then
		SONG = 152623511
	elseif SONG == 152623511 then
		SONG = 467676551
	elseif SONG == 467676551 then
		SONG = 4389772331				
	end
end

local headhold = false
local holdinghead

function spillmilk()
	ATTACK = true
	if not botopen then
	botopen = true
	else	
	end
	for i = 0,20 do
		Swait()
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.3,-0.3,-1.1)*ANGLES(RAD(92.1),RAD(-37.6),RAD(131.6)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	local m2 = cm.tors.insidebottom.milk
	m2.Parent = nil
	local milgkc = milgk:Clone()
	milgkc.Parent = Effects
	milgkc.Anchored = false
	local milkweld = weld(milgkc,milgkc,cm.la.hand,CF(1,0,0)*ANGLES(RAD(0),RAD(0),RAD(270)),d)
	for i = 0,17 do
		Swait()
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(10.4),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-10.4),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(-10.4),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.2,0.5,0.3)*ANGLES(RAD(-150.8),RAD(-16.9),RAD(-19.4)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(8)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	local endpoint = cm.ll.timb.CFrame*CF(.8,-.8,10)
	RootPart.Anchored = true
	milgkc:BreakJoints()
	milgkc.Anchored = true
	coroutine.resume(coroutine.
	create(function()
	milgkc.CFrame = CF(milgkc.Position,endpoint.p)
	for i = 1,10 do
		Swait()
		milgkc.CFrame = milgkc.CFrame*CF(0,0,-2)
		--local hit,pos = Raycast(milgkc.Position,milgkc.CFrame.lookVector,5,Character)
		--if hit then break end
	end
	for i = 1,60 do
		local ch=MRANDOM(50,100)/100
		local milk = CreatePart(3,Effects,"SmoothPlastic",0,0,"White","milk",VT(ch,ch,ch),false) milk.CanCollide = false
		MakeForm(milk,"Ball")
		milk.CFrame = milgkc.CFrame
		local bv = IT("BodyVelocity",milk)
		bv.Velocity = CF(milk.Position,milk.CFrame*CF(MRANDOM(-10,10)/2,2,MRANDOM(-10,10)/2).p).lookVector*50
		Debris:AddItem(bv,.1)
		Debris:AddItem(milk,1.8)
	end
		milgkc:Destroy()
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(20,20,20), Transparency = 0, Transparency2 = 1, CFrame = milgkc.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = 2978605361, SoundPitch = 1.4, SoundVolume = 5, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(15,15,15), Transparency = 0, Transparency2 = 1, CFrame = milgkc.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = 2978605361, SoundPitch = 1.4, SoundVolume = 5, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		WACKYEFFECT2({Time = 45, EffectType = "Sphere", Size = VT(1,.1,1), Size2 = VT(30,.1,30), Transparency = 0, Transparency2 = 1, CFrame = endpoint*CF(0,0,5)*ANGLES(0,0,RAD(90)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
ApplyAoE(endpoint.p,10,50,70,50,false)
	end))
	for i = 0,5 do   	la.C0 = la.C0:lerp(CF(-1.2,0.5,-0.4)*ANGLES(RAD(124),RAD(18.9),RAD(-17.5)),.1) end
	for i = 0,13 do Swait()
		  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,0)*ANGLES(RAD(-30.2),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.2)*ANGLES(RAD(30.2),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-0.9,-0.2)*ANGLES(RAD(30.2),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1,0.6,-1.1)*ANGLES(RAD(34.3),RAD(18.6),RAD(52.3)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(8)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
		botopen = false
	RootPart.Anchored = false
	m2.Parent = cm.tors.insidebottom
	ATTACK = false
end


function invokefridge()
	ATTACK = true
	for i = 0,20 do
		Swait()
			local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(11.8),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-11.8),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(-11.8),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5,1.2,0.4)*ANGLES(RAD(-161.4),RAD(0),RAD(0)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	local hf,hp = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 3.7, Character)
	if hf then
	local sort
	local chosen
	if MRANDOM(1,2) == 1 then
		chosen = "fridge"
		sort = attackfridge:Clone()
	else
		chosen = "timb"
		sort = attacktimb:Clone()	
	end
	sort.Parent = workspace
	local startpos = Mouse.Hit*CF(0,30,0)
	sort.CFrame = startpos
	sort.Orientation = VT(0,RootPart.Orientation.Y,0)
	if chosen =="timb" then
	sort.CFrame = sort.CFrame*ANGLES(RAD(0),RAD(0),RAD(-90))	
	end
	swait(.5)
	local endpos = sort.Position-VT(0,sort.Position.Y/1.12,0)
	local timer
	if chosen=="timb" then timer=7 else timer=6.5 end
--	local hf2,hp2 = Raycast(sort.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 3.7, Character)

	coroutine.resume(coroutine.create(function()
	for i = 1,timer do
		Swait()
		if chosen == "fridge" then
		sort.CFrame = sort.CFrame*CF(0,-3.5,0)
		else
			sort.CFrame = sort.CFrame*CF(3.5,0,0)
		end	
	end
	sort.Position = endpos
	CreateSound(1902416645,sort,7,1,false)
	WACKYEFFECT2({Time = 30, EffectType = "Wave", Size = VT(1,.2,1), Size2 = VT(15,.2,15), Transparency = 0, Transparency2 = 1, CFrame = CF(endpos)*CF(0,-2,0), MoveToPos = nil, RotationX = 0, RotationY = 8, RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	swait(1)
	WACKYEFFECT2({Time = 50, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(50,50,50), Transparency = 0, Transparency2 = 1, CFrame = CF(endpos)*CF(0,-2.7,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255, 106, 6),SoundID = 157878578, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 5})
	WACKYEFFECT2({Time = 50, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(40,40,40), Transparency = 0, Transparency2 = 1, CFrame = CF(endpos)*CF(0,-2.7,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255, 106, 6),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 5})
	for i = 1,5 do
		WACKYEFFECT2({Time = 60, EffectType = "Round Slash", Size = VT(.01,.03,.01), Size2 = VT(.3,.05,.3), Transparency = 0, Transparency2 = 1, CFrame = CF(endpos)*CF(0,-2.7,0)*ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-3,3), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end
	for i = 1,30 do
		WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(1,1,1), Size2 = VT(.9,.9,.9), Transparency = 0, Transparency2 = 1, CFrame = CF(endpos)*CF(0,-2,0), MoveToPos = endpos+VT(MRANDOM(-20,20),MRANDOM(0,20),MRANDOM(-20,20))*2, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.fromRGB(255, 106, 6),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})

	end
	ApplyAoE(endpos,30,0,0,100,true)
	if chosen == "fridge" then
local f1 = New("Part",sort,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(0.206073254, 0.97884798, 0.0367987975),CFrame = CFrame.new(-28.9052696, 9.98226261, -89.2309799, 1, 0, 0, 0, 1, 0, 0, 0, 1),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
local f2 = New("Part",sort,"Part",{BrickColor = BrickColor.new("Ghost grey"),Material = Enum.Material.Metal,Size = Vector3.new(3.62100148, 6.04972219, 2.80406785),CFrame = CFrame.new(-30.2859879, 7.9991641, -90.7753067, -1, 0, 0, 0, 1, 0, 0, 0, -1),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.792157, 0.796078, 0.819608),})
local f3 = New("Part",sort,"Part",{BrickColor = BrickColor.new("Ghost grey"),Material = Enum.Material.Metal,Size = Vector3.new(3.33396935, 1.89145613, 0.22079277),CFrame = CFrame.new(-30.2792377, 9.95251274, -89.3609238, 1, 0, 0, 0, 1, 0, 0, 0, 1),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.792157, 0.796078, 0.819608),})
local f4 = New("Part",sort,"Part",{BrickColor = BrickColor.new("Ghost grey"),Material = Enum.Material.Metal,Size = Vector3.new(3.32661057, 3.63572121, 0.22079277),CFrame = CFrame.new(-30.2755375, 7.00484943, -89.3609238, 1, 0, 0, 0, 1, 0, 0, 0, 1),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.792157, 0.796078, 0.819608),})
local f5 = New("Part",sort,"Part",{BrickColor = BrickColor.new("Smoky grey"),Material = Enum.Material.Metal,Size = Vector3.new(0.206073254, 0.97884798, 0.0367987975),CFrame = CFrame.new(-28.9052696, 8.04797935, -89.2309799, 1, 0, 0, 0, 1, 0, 0, 0, 1),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,Color = Color3.new(0.356863, 0.364706, 0.411765),})
	local parts = {}
	for i,v in pairs(sort:GetChildren()) do
		if v:IsA("BasePart") then
		table.insert(parts,v)
		end
	end
	for i = 1,#parts do
	parts[i].CFrame = sort.CFrame
	parts[i].Parent = workspace
	parts[i].Material = "Metal"
	local bv = IT("BodyVelocity",parts[i])
	bv.Velocity = CF(parts[i].Position,parts[i].CFrame*CF(MRANDOM(-10,10)/2,2,MRANDOM(-10,10)/2).p).lookVector*100
	Debris:AddItem(bv,.1)
	Debris:AddItem(parts[i],2)
	end
	sort:Destroy()
	else
	for i = 1,15 do
	local deb = CreatePart(3,Effects,"Concrete",0,0,"Br. yellowish orange","timbparts",VT(MRANDOM(2,9)/5,MRANDOM(2,9)/5,MRANDOM(2,9)/5),false)
	deb.CFrame = sort.CFrame	
	deb.CanCollide = true
	local bv = IT("BodyVelocity",deb)
	bv.Velocity = CF(deb.Position,deb.CFrame*CF(MRANDOM(-10,10),2,MRANDOM(-10,10)).p).lookVector*100
	Debris:AddItem(bv,.1)
	Debris:AddItem(deb,2)
	end
	sort:Destroy()
	end
	
	end))
	for i = 0,15 do
		Swait()
		  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0.1,0)*ANGLES(RAD(-4.1),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,-0.1)*ANGLES(RAD(4.1),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,-0.1)*ANGLES(RAD(4.1),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5,0.4,-0.1)*ANGLES(RAD(94),RAD(0),RAD(0)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	end
	ATTACK = false
end

local cheadweld
	
function boozify()
	ATTACK = true
	local o2 = Instance.new("ParticleEmitter")o2.Name = "cold"o2.Parent = nil;o2.Transparency = NumberSequence.new(1,0.75625002384186,1)o2.Rotation = NumberRange.new(-180,-180)o2.Size = NumberSequence.new(0,1.25)o2.Texture = "rbxasset://textures/particles/smoke_main.dds"o2.Lifetime = NumberRange.new(1.75,1.75)o2.Rate = 35;o2.RotSpeed = NumberRange.new(1,1)o2.Speed = NumberRange.new(1,3)o2.VelocitySpread = 360	
	local isgrab = false
	local wel
	local ttors
	local hb = CreatePart(3,Effects,"Plastic",0,1,"White","hitbox",VT(4, 4, 4),false)
	local hbw = weld(cm.la.hand,hb,cm.la.hand,CF(0,0,0),d)
	local hitt = hb.Touched:Connect(function(h)
	if h.Parent:FindFirstChildOfClass("Humanoid") then
	if h.Parent:FindFirstChildOfClass("Humanoid").Health ~= 0 then
	ttors = h.Parent:FindFirstChild("Torso") or h.Parent:FindFirstChild("UpperTorso")
	hd = ttors.Parent:FindFirstChild("Head")
	pw = weld(hd,hd,cm.la.hand,d*ANGLES(RAD(90),0,RAD(180)),d)
	CreateSound(260411131,hd,6,1,false)
	for x,p in pairs(ttors.Parent:GetChildren()) do
	if p:IsA("BasePart") then
	p.Massless = true
	end
	end
	isgrab = true
	end	
	end
	end)
	for i = 0,20 do
		Swait()
		if isgrab == true then break end
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,0,0)*ANGLES(RAD(0),RAD(-13.7),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5,0.3,-1.1)*ANGLES(RAD(93.1),RAD(-3.8),RAD(-10.4)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0.1,0,0)*ANGLES(RAD(0),RAD(13.7),RAD(0)),Alpha)
	end
	hb:Destroy()
	hitt:Disconnect()
	if isgrab == true then
	local a = false
	coroutine.resume(coroutine.create(function()
	repeat	Swait()
		  	local Alpha = .1
	pw.C0 = pw.C0:lerp(d*ANGLES(RAD(90),RAD(-90),RAD(180)),.1)
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.4,0.4,0)*ANGLES(RAD(0),RAD(0),RAD(-92.1)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
until a == true
	end))
	swait(1.2)
	for q,y in pairs(ttors.Parent:GetDescendants()) do
	if y:IsA("BasePart") then
	y.Color = Color3.fromRGB(175, 221, 255)
	y.Material = "Ice"
	local oclone = o2:Clone()
	oclone.Parent = y
	CreateSound(268249319,ttors,4,2,false)
	WACKYEFFECT2({Time = 20, EffectType = "Box", Size = y.Size, Size2 = y.Size*1.1, Transparency = 0, Transparency2 = 1, CFrame = y.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Ice", Color = Color3.fromRGB(175, 221, 255),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	end	
	if y:IsA("SpecialMesh") or y:IsA("FileMesh") then
	y.TextureId	= ""
	end
	if y:IsA("Shirt") or y:IsA("Pants") then
	y:Destroy()	
	end
	if y:IsA("CharacterMesh") then
	y:Destroy()	
	end
	end
	local hc = hd:Clone()
	hc.Parent = Effects
	hd:BreakJoints()
	hd:Destroy()
	ttors.Parent:BreakJoints()
	a = true
	spawn(function()
	topopen= true	
	swait(.6)
	for i = 0,5 do
	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.1,0.4,-0.8)*ANGLES(RAD(-178.9),RAD(-28.8),RAD(92.3)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	for i = 0,15 do
		Swait()
		  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-0.7,0.8,-1.2)*ANGLES(RAD(-120.2),RAD(9.4),RAD(36.4)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
		holdinghead = hc
		hc:BreakJoints()
		hc.cold:Destroy()
		local w = weld(hc,hc,headpoint,d,d)
		headhold = true
		topopen = false
	end)
	end
	o2:Destroy()
	ATTACK = false
end

function throwhead()
	ATTACK = true
	if headhold == true then
	topopen = true
	for i = 0,5 do
	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.1,0.4,-0.8)*ANGLES(RAD(-178.9),RAD(-28.8),RAD(92.3)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	for i = 0,15 do
		Swait()
		  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-0.7,0.8,-1.2)*ANGLES(RAD(-120.2),RAD(9.4),RAD(36.4)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	holdinghead:BreakJoints()
	local newtempw = weld(holdinghead,holdinghead,cm.la.hand,d*ANGLES(RAD(90),0,RAD(180)),d)
			for i = 0,20 do
		Swait()
			local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0.2)*ANGLES(RAD(11.8),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(-11.8),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(-11.8),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.5,1.2,0.4)*ANGLES(RAD(-161.4),RAD(0),RAD(0)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
			end
		newtempw:Destroy()
		holdinghead.Anchored = true
		coroutine.resume(coroutine.create(function()
		holdinghead.CFrame = CF(holdinghead.Position,Mouse.Hit.p)
				topopen = false
		for i = 1,250 do
			Swait()
			holdinghead.CFrame = holdinghead.CFrame*CF(0,0,-4)
			 hit,pos = Raycast(holdinghead.Position,holdinghead.CFrame.lookVector,5,Character)
			if hit then break end
		end
		for i = 1,5 do
		local blocks = CreatePart(3,Effects,"Ice",0,0,"Baby blue","ice cube",VT(.3,.3,.3)*3,false)
		blocks.CanCollide = true
		blocks.CFrame = CF(pos)
		for i = 1,3 do
		WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(1,1,1)*2, Size2 = VT(2,2,2)*2, Transparency = 0, Transparency2 = 1, CFrame = blocks.CFrame, MoveToPos = blocks.Position+VT(MRANDOM(-1,1),MRANDOM(-1,1),MRANDOM(-1,1)), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "SmoothPlastic", Color = Color3.fromRGB(212, 238, 254),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
		end
		WACKYEFFECT2({Time = 60, EffectType = "Box", Size = VT(holdinghead.Size.Z,holdinghead.Size.Y,holdinghead.Size.Z), Size2 = VT(holdinghead.Size.Z,holdinghead.Size.Y,holdinghead.Size.Z)*1.3, Transparency = 0, Transparency2 = 1, CFrame = holdinghead.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = holdinghead.Material, Color = holdinghead.Color,SoundID = 87015121, SoundPitch = 1.8, SoundVolume = 7, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
			
			local bv = IT("BodyVelocity",blocks)
	bv.Velocity = CF(blocks.Position,blocks.CFrame*CF(MRANDOM(-10,10),2,MRANDOM(-10,10)).p).lookVector*30
	Debris:AddItem(bv,.1)
	Debris:AddItem(blocks,2)
		end
		ApplyAoE(holdinghead.Position,10,60,80,70,false)
		holdinghead:Destroy()
		holdinghead = nil
		headhold = false
		end))
		--0for i = 0,5 do   	la.C0 = la.C0:lerp(CF(-1.2,0.5,-0.4)*ANGLES(RAD(124),RAD(18.9),RAD(-17.5)),.1) end
	for i = 0,13 do Swait()
		  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,-0.1,0)*ANGLES(RAD(-15.2),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-0.9,-0.2)*ANGLES(RAD(15.2),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-0.9,-0.2)*ANGLES(RAD(15.2),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1,0.6,-1.1)*ANGLES(RAD(34.3),RAD(18.6),RAD(52.3)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.4,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(8)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end	
	end
	ATTACK = false
end
	
function charge()
	ATTACK = true
		local hb = CreatePart(3,Effects,"Neon",0,1,"White","hitbox",cm.la.armpart.Size*5+VT(0,4,2)-VT(4,0,0),false)
		hb.CanCollide = false
		hb.Massless = true
		local hbw = weld(hb,hb,cm.la.armpart,d,d)
		local ish = false
		local hitt = hb.Touched:Connect(function(h)
		if h.Parent:FindFirstChildOfClass("Humanoid") then
			if h.Parent.HumanoidRootPart then
				if ish == false then ish = true end
				h.Parent.HumanoidRootPart.CFrame = h.Parent.HumanoidRootPart.CFrame*ANGLES(0,0,RAD(180))
				--[[ApplyDamage(h.Parent:FindFirstChildOfClass("Humanoid"),MRANDOM(60,90))
				local bv = IT("BodyVelocity",h.HumanoidRootPart)
				bv.Velocity = CF(h.Parent.HumanoidRootPart.Position,h.Parent.HumanoidRootPart,CF(0,-5,0).p).lookVector*40
				Debris:AddItem(bv,.1)]]
			end
		end	
		end)
	for i = 0,20 do
		Swait()
			local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0.1,0.5)*ANGLES(RAD(28.6),RAD(0),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1.2,0.1)*ANGLES(RAD(-28.6),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1.2,0.1)*ANGLES(RAD(-28.6),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-2.6,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(-91.9)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(2.6,0.4,0)*ANGLES(RAD(0),RAD(0),RAD(89.3)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
	end
	Rooted = true
	for i = 0,100 do
		Swait()
		  	local Alpha = .3
	WACKYEFFECT2({Time = 30, EffectType = "Wave", Size = VT(2,2,2), Size2 = VT(13,2,13), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame*CF(0,0,-2)*ANGLES(RAD(-90),RAD(0),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-10,10), RotationZ = 0, Material = "Neon", Color = C3(1,1,1),SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 0})
	ApplyAoE(hb.Position,4,30,40,100,false)
	CreateSound(10730819,Torso,6,1,false)
	RootPart.CFrame	= RootPart.CFrame*CF(0,0,-1.5)
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(-45.2),RAD(0))*ROOTC0,Alpha)
  	lh.C0 = lh.C0:lerp(CF(-0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	rh.C0 = rh.C0:lerp(CF(0.5,-1,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	la.C0 = la.C0:lerp(CF(-1.8,0.5,-1.1)*ANGLES(RAD(82),RAD(-19.7),RAD(41.1)),Alpha)
  	ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  	Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(45.2),RAD(0)),Alpha)
	end
	hitt:Disconnect()
	hb:Destroy()
	Rooted = false
	ATTACK = false
end	

local bparts = {cm.la,cm.ra,cm.ll,cm.rl}
	
	
--keys
function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key=="q" and topopen == false then topopen = true elseif Key=="q" and topopen == true then topopen = false end
	if Key=="e" and botopen == false then botopen = true elseif Key=="e" and botopen == true then botopen = false end
	if Key == "r" and hidden == false then hidden = true  Rooted = true RootPart.Anchored = true
	for i = 1,#bparts do bparts[i].Parent = nil end
	elseif Key =="r" and hidden == true then  hidden = false Rooted = false RootPart.Anchored = false
	for i = 1,#bparts do bparts[i].Parent = cm end
	end
	if hidden == false then
	if Key == "z" and ATTACK == false then
		spillmilk()
	end
	if Key == "x" and ATTACK == false then
		invokefridge()
	end

	if Key == "c" and ATTACK == false and headhold == false then	
		boozify()
	elseif 	Key == "c" and ATTACK == false and headhold == true then
		throwhead()	
	end

	if Key == "v" and ATTACK == false then
		charge()
	end

	if Key == "b" and ATTACK == false then
		
	end
	
	if Key=="m" then cs() end

	if Key == "]" and ATTACK == false then
		if sick.Parent ~= Character then
			sick = IT("Sound",Torso)
			sick.SoundId = "rbxassetid://"..SONG
		end
	end
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--loop stuff

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

while true do
	Swait()
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE*2
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
	local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
	local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
			la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
			rh.C0 = Clerp(rh.C0, CF(.5, -0.4, -0.6) * ANGLES(RAD(1), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			lh.C0 = Clerp(lh.C0, CF(-.5, -1, 0) * ANGLES(RAD(0), RAD(5), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			ra.C0 = Clerp(ra.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))), 1 / Animation_Speed)
			la.C0 = Clerp(la.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))), 1 / Animation_Speed)
			rh.C0 = Clerp(rh.C0, CF(.5, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(0), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			lh.C0 = Clerp(lh.C0, CF(-.5, -0.8, -0.3) * ANGLES(RAD(-10), RAD(10), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		local Alpha = .1
		ANIM = "Idle"
		if ATTACK == false then
		if hidden == false then
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0+0.07*COS(SINE/35),0)*ANGLES(RAD(0),RAD(0),RAD(0+2*COS(SINE/70)))*ROOTC0,Alpha)
  		lh.C0 = lh.C0:lerp(CF(-0.5,-1-0.07*COS(SINE/35),0)*ANGLES(RAD(0),RAD(0),RAD(0-2*COS(SINE/70))),Alpha)
  		rh.C0 = rh.C0:lerp(CF(0.5,-1-0.07*COS(SINE/35),0)*ANGLES(RAD(0),RAD(0),RAD(0-2*COS(SINE/70))),Alpha)
  		la.C0 = la.C0:lerp(CF(-1.5,0.5+0.15*COS(SINE/35),0+.1*SIN(SINE/35))*ANGLES(RAD(0+2.6*SIN(SINE/35)),RAD(0),RAD(-3+3*COS(SINE/35))),Alpha)
  		ra.C0 = ra.C0:lerp(CF(1.5,0.5+0.15*COS(SINE/35),0+.1*SIN(SINE/35))*ANGLES(RAD(0+2.6*SIN(SINE/35)),RAD(0),RAD(3-3*COS(SINE/35))),Alpha)
  		Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0 + ((1) - 1))*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
		else
		local Alpha = .5
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,-1.35,0)*ANGLES(RAD(0),RAD(0),RAD(0))*ROOTC0,Alpha)
  		lh.C0 = lh.C0:lerp(CF(-0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  		rh.C0 = rh.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  		la.C0 = la.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  		ra.C0 = ra.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
  		Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0+ ((1) - 1))*CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),Alpha)
		end
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,0+0.08*SIN(SINE/WALKSPEEDVALUE*2),0-.10*COS(SINE/(WALKSPEEDVALUE/2)))*ANGLES(RAD(-2+3*SIN(SINE/(WALKSPEEDVALUE/2)))+RAD(TiltVelocity.Z)*1,RAD(10*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ROOTC0,Alpha)
  		lh.C0 = lh.C0:lerp(CF(-0.5,-.9+0.55*COS(SINE/WALKSPEEDVALUE)/2,-.1-.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5+15*COS(SINE/WALKSPEEDVALUE))+RootPart.RotVelocity.Y/-75+SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.Z)*10,RAD(0-5*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ANGLES(RAD(0-2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0+25*SIN(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*5.5)),Alpha)
  		rh.C0 = rh.C0:lerp(CF(0.5,-.9-0.55*COS(SINE/WALKSPEEDVALUE)/2,-.1+.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5-15*COS(SINE/WALKSPEEDVALUE))-RootPart.RotVelocity.Y/75+-SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.Z)*10,RAD(0-5*COS(SINE/WALKSPEEDVALUE)),RAD(0))*ANGLES(RAD(0+2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0+25*SIN(SINE/WALKSPEEDVALUE)*-RAD(TiltVelocity.X)*5.5)),Alpha)
  		la.C0 = la.C0:lerp(CF(-1.5,0.5,0)*ANGLES(RAD(-28*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
  		ra.C0 = ra.C0:lerp(CF(1.5,0.5,0)*ANGLES(RAD(28*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
  		Neck.C0 = Neck.C0:lerp(NECKC0*CF(0,0,0)*ANGLES(RAD(0+3.5*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(-10*COS(SINE/WALKSPEEDVALUE))-RAD(TiltVelocity.X)*3),Alpha)
		end
	end
	if topopen == true then
	topw.C0 = topw.C0:lerp(CF(.35,0,-3.5)*ANGLES(RAD(0),RAD(-90),RAD(0)),.2)
	else
	topw.C0 = topw.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),.2)
	end
	if botopen == true then
	bottomw.C0 = bottomw.C0:lerp(CF(.35,0,-3.5)*ANGLES(RAD(0),RAD(-90),RAD(0)),.2)
	else
	bottomw.C0 = bottomw.C0:lerp(CF(0,0,0)*ANGLES(RAD(0),RAD(0),RAD(0)),.2)
	end
	unanchor()
	Humanoid.MaxHealth = 1e4
	Humanoid.Health = 1e4
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..SONG
	sick.Looped = true
	sick.Pitch = 1
	sick.Volume = 3
	if hidden == false then
	sick.Playing = true
	else
	sick.Playing = false
	end	
end
